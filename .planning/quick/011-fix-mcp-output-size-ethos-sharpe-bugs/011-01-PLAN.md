---
phase: quick-011
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mcp-server/src/tools/performance.ts
autonomous: true

must_haves:
  truths:
    - "compare_backtest_to_actual output stays under MCP limits for large blocks"
    - "matchedOnly parameter actually filters the comparisons array"
    - "Unmatched trades are summarized, not listed individually"
    - "Auto-filter restricts comparison to reporting log date range overlap"
    - "get_performance_charts output stays under MCP limits for large blocks"
    - "maxDataPoints parameter truncates per-trade chart data with truncation flag"
    - "Summary stats only aggregate matched comparisons with separate unmatched fields"
    - "Strategy names containing pipe characters are not truncated in compare_backtest_to_actual"
    - "Streak data runs test has no interpretation field"
  artifacts:
    - path: "packages/mcp-server/src/tools/performance.ts"
      provides: "Output size-limited, bug-fixed, ethos-clean performance tools"
---

<objective>
Fix all issues in performance.ts: MCP output size limits (Issues 1+2), summary stats bug (Issue 9), pipe-character strategy name truncation (Issue 8), and streak data interpretation removal (Issue 6e).

Purpose: Large blocks exceed MCP limits, summary stats are misleading, strategy names get truncated, and interpretation violates data-only ethos.
Output: performance.ts with bounded output, accurate stats, correct names, and no interpretive labels.
</objective>

<execution_context>
@/Users/davidromeo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidromeo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@packages/mcp-server/src/tools/performance.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix compare_backtest_to_actual (Issues 1, 8, 9)</name>
  <files>packages/mcp-server/src/tools/performance.ts</files>
  <action>
Five changes in the compare_backtest_to_actual tool:

**(Issue 8) Fix pipe-character strategy name truncation:**
The summary mode uses `|` as delimiter in composite keys (lines ~2185, 2199, 2214, 2280), but strategy names can contain `|`. Change ALL key construction and parsing to use `\t` (tab) instead of `|`:
- Lines ~2185: `const key = \`${dateKey}\t${trade.strategy}\``
- Lines ~2199: `const key = \`${dateKey}\t${trade.strategy}\``
- Lines ~2214: `const [dateKey, ...strategyParts] = key.split("\t"); const strategyName = strategyParts.join("\t");`
  Actually, with tab delimiter it will always be exactly 2 parts since neither date nor strategy contain tabs. So: `const [dateKey, strategyName] = key.split("\t")`
- Lines ~2280: Same fix as above

Also fix trade-level matching keys (lines ~1976-1978, ~1988) to use `\t`:
- `const key = \`${dateKey}\t${trade.strategy}\t${timeKey}\``

**(Issue 1a) Fix matchedOnly parameter:**
After outlier detection (line ~2380) and before the outliersOnly filter, add:
```typescript
if (matchedOnly) {
  comparisons = comparisons.filter((c) => c.matched);
}
```

**(Issue 1b) Summarize unmatched trades:**
After building all comparisons and BEFORE outlier detection, separate matched from unmatched:
- Extract unmatched entries from comparisons array
- Build unmatched summaries: `unmatchedBacktestSummary` = { count, dateRange: {from, to}, totalPl, strategies: string[] } and `unmatchedActualSummary` = same shape
- Remove unmatched entries from the comparisons array (keep only matched)
- Store summaries in a variable for later inclusion in structuredData

**(Issue 1c) Auto-filter by reporting log date range:**
After loading and filtering both trade sets (before matching), if user did NOT provide dateRange:
```typescript
if (!dateRange) {
  const actualDates = actualTrades.map(t => formatDateKey(new Date(t.dateOpened)));
  if (actualDates.length > 0) {
    const minActualDate = actualDates.reduce((a, b) => a < b ? a : b);
    const maxActualDate = actualDates.reduce((a, b) => a > b ? a : b);
    backtestTrades = backtestTrades.filter(t => {
      const d = formatDateKey(new Date(t.dateOpened));
      return d >= minActualDate && d <= maxActualDate;
    });
  }
}
```
Add a note in the tool description: "When no dateRange is specified, comparison is auto-limited to the reporting log's date range overlap."

**(Issue 9) Fix summary stats to matched-only:**
Replace summary computation (lines ~2429-2452) to always compute from matched comparisons:
```typescript
const matchedForSummary = comparisons.filter((c) => c.matched);
```
Use `matchedForSummary` for totalBacktestPl, totalActualPl, totalSlippage, avgSlippage, avgSlippagePercent.
Add separate fields: `unmatchedBacktestCount`, `unmatchedActualCount`, `unmatchedBacktestPl`, `unmatchedActualPl`.
Update the `note` to: "Summary stats are computed from matched comparisons only. Unmatched trades are reported separately."

Include the `unmatchedSummary` from Issue 1b in structuredData as a top-level field.
  </action>
  <verify>Run `npm run typecheck` to confirm no type errors.</verify>
  <done>compare_backtest_to_actual: matchedOnly works, unmatched summarized, auto date overlap, matched-only summary stats, pipe-safe strategy names.</done>
</task>

<task type="auto">
  <name>Task 2: Fix get_performance_charts + streak interpretation (Issues 2, 6e)</name>
  <files>packages/mcp-server/src/tools/performance.ts</files>
  <action>
**(Issue 2) Add maxDataPoints parameter to get_performance_charts:**

1. Add parameter to inputSchema:
```typescript
maxDataPoints: z
  .number()
  .min(50)
  .max(10000)
  .default(500)
  .describe(
    "Maximum data points for per-trade chart types (volatility_regimes, mfe_mae, trade_sequence, holding_periods, premium_efficiency, margin_utilization, rom_timeline). When exceeded, data is truncated with a flag. Default: 500."
  ),
```

2. Add to handler destructuring.

3. Create helper inside handler:
```typescript
let anyTruncated = false;
function truncateArray<T>(arr: T[]): T[] | { data: T[]; truncated: true; totalPoints: number } {
  if (arr.length <= maxDataPoints) return arr;
  anyTruncated = true;
  return { data: arr.slice(0, maxDataPoints), truncated: true, totalPoints: arr.length };
}
```

4. Apply to per-trade chart types:
- `volatility_regimes`: `chartData.volatilityRegimes = truncateArray(buildVolatilityRegimes(trades));`
- `trade_sequence`: `chartData.tradeSequence = truncateArray(buildTradeSequence(trades));`
- `holding_periods`: `chartData.holdingPeriods = truncateArray(buildHoldingPeriods(trades));`
- `premium_efficiency`: `chartData.premiumEfficiency = truncateArray(buildPremiumEfficiency(trades));`
- `margin_utilization`: `chartData.marginUtilization = truncateArray(buildMarginUtilization(trades, equityCurve));`
- `rom_timeline`: `chartData.romTimeline = truncateArray(buildRomTimeline(trades));`
- `mfe_mae`: For this one, truncate just the `dataPoints` array within the object. After building the full mfeMae object, do:
  ```typescript
  if (simplifiedData.length > maxDataPoints) {
    anyTruncated = true;
    chartData.mfeMae = {
      dataPoints: { data: simplifiedData.slice(0, maxDataPoints), truncated: true, totalPoints: simplifiedData.length },
      distribution,
      statistics: { ... },
    };
  }
  ```

5. Add `truncationApplied: anyTruncated` to structuredData.

6. Update data points counting to account for truncation (use the actual output length, not the pre-truncation length).

7. Update tool description to note high-volume chart types.

**(Issue 6e) Remove interpretation from streak data runs test:**
In the `calculateRunsTest` function (line ~536), remove the `interpretation` field from:
- The return type (lines ~543, ~461)
- The return object (lines ~574, ~579-584, ~592)
- The buildStreakData return type (lines ~459-461)

Delete the interpretation variable construction and remove it from the return. Keep numRuns, expectedRuns, zScore, pValue, isNonRandom, patternType.
  </action>
  <verify>Run `npm run typecheck` to confirm no type errors.</verify>
  <done>Per-trade charts truncated at maxDataPoints. Streak runs test has no interpretation field.</done>
</task>

</tasks>

<verification>
- `npm run typecheck` passes
- All tools in performance.ts compile without errors
</verification>

<success_criteria>
- compare_backtest_to_actual: bounded output, correct names, accurate stats
- get_performance_charts: bounded output via maxDataPoints
- streak_data: no interpretation field
</success_criteria>

<output>
After completion, create `.planning/quick/011-fix-mcp-output-size-ethos-sharpe-bugs/011-01-SUMMARY.md`
</output>
