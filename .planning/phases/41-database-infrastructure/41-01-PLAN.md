---
phase: 41-database-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mcp-server/package.json
  - packages/mcp-server/src/db/connection.ts
  - packages/mcp-server/src/db/index.ts
  - packages/mcp-server/src/index.ts
autonomous: true

must_haves:
  truths:
    - "DuckDB connection initializes lazily on first getConnection() call"
    - "Connection is reused for subsequent calls (singleton pattern)"
    - "Schemas 'trades' and 'market' exist after first connection"
    - "enable_external_access is disabled (no remote URL fetching)"
    - "Memory and thread limits are configurable via environment variables"
    - "Graceful shutdown closes connection on process exit"
  artifacts:
    - path: "packages/mcp-server/src/db/connection.ts"
      provides: "Lazy singleton DuckDB connection manager"
      exports: ["getConnection", "closeConnection"]
      min_lines: 60
    - path: "packages/mcp-server/src/db/index.ts"
      provides: "Public exports for db module"
      exports: ["getConnection", "closeConnection"]
  key_links:
    - from: "packages/mcp-server/src/index.ts"
      to: "src/db/connection.ts"
      via: "process signal handlers call closeConnection"
      pattern: "closeConnection"
---

<objective>
Integrate DuckDB into the MCP server with lazy initialization, resource configuration, and graceful shutdown.

Purpose: Establish the database foundation that all subsequent phases (sync, query, schema discovery) will build upon.

Output: Working DuckDB connection manager with proper configuration and cleanup.
</objective>

<execution_context>
@/Users/davidromeo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidromeo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-database-infrastructure/41-CONTEXT.md
@.planning/phases/41-database-infrastructure/41-RESEARCH.md
@packages/mcp-server/src/index.ts
@packages/mcp-server/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DuckDB dependency and create connection manager</name>
  <files>
    packages/mcp-server/package.json
    packages/mcp-server/src/db/connection.ts
    packages/mcp-server/src/db/index.ts
  </files>
  <action>
1. Add `@duckdb/node-api` to dependencies in package.json (version ^1.4.3)

2. Create `src/db/connection.ts` with lazy singleton pattern:
   - Module-level variables: `instance: DuckDBInstance | null`, `connection: DuckDBConnection | null`
   - `getConnection(dataDir: string)`:
     - Return existing connection if available
     - Create DuckDBInstance at `path.join(dataDir, 'analytics.duckdb')` with config:
       - threads: `process.env.DUCKDB_THREADS || '2'`
       - memory_limit: `process.env.DUCKDB_MEMORY_LIMIT || '512MB'`
       - enable_external_access: `'false'`
     - Connect and store connection
     - Run `CREATE SCHEMA IF NOT EXISTS trades`
     - Run `CREATE SCHEMA IF NOT EXISTS market`
     - Return connection
   - `closeConnection()`:
     - If connection exists, call `connection.closeSync()`
     - Set connection and instance to null
   - Handle errors with clear messages (per CONTEXT.md: no auto-rebuild on corruption)

3. Create `src/db/index.ts` that re-exports `getConnection` and `closeConnection`

Use imports from `@duckdb/node-api`: `DuckDBInstance`, `DuckDBConnection`
  </action>
  <verify>
    TypeScript compiles: `npm run build` in packages/mcp-server succeeds
  </verify>
  <done>
    - @duckdb/node-api in package.json dependencies
    - connection.ts exports getConnection and closeConnection
    - getConnection creates analytics.duckdb with trades/market schemas
    - Configuration uses env vars with sensible defaults
    - enable_external_access is 'false' at instance creation
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire graceful shutdown to MCP server</name>
  <files>
    packages/mcp-server/src/index.ts
  </files>
  <action>
1. Import `closeConnection` from `./db/index.js`

2. In the main() function, after the server starts (both stdio and http branches), register shutdown handlers:
   ```typescript
   // Graceful shutdown for DuckDB
   const shutdown = async () => {
     await closeConnection();
     process.exit(0);
   };
   process.on('SIGINT', shutdown);
   process.on('SIGTERM', shutdown);
   ```

3. For stdio mode, the shutdown handlers ensure DuckDB closes before exit.
   For http mode, they work the same way.

Note: Don't call getConnection at startup (lazy init). The handlers just ensure cleanup IF a connection was opened during the session.
  </action>
  <verify>
    - `npm run build` succeeds in packages/mcp-server
    - Server starts normally: `TRADEBLOCKS_DATA_DIR=~/backtests node packages/mcp-server/server/index.js --call list_blocks '{}'` works
  </verify>
  <done>
    - index.ts imports closeConnection from db module
    - SIGINT and SIGTERM handlers call closeConnection
    - Server still starts and works normally (no eager DB init)
  </done>
</task>

</tasks>

<verification>
1. `npm run build` in packages/mcp-server succeeds without errors
2. Server starts and list_blocks works (DB not initialized yet, that's expected)
3. Type-check passes: `npx tsc --noEmit` in packages/mcp-server
4. New files exist:
   - packages/mcp-server/src/db/connection.ts
   - packages/mcp-server/src/db/index.ts
</verification>

<success_criteria>
- DuckDB dependency added to MCP server
- Connection manager implements lazy singleton with proper configuration
- Both schemas (trades, market) created on first connection
- Security setting (enable_external_access=false) applied at instance creation
- Resource limits configurable via DUCKDB_MEMORY_LIMIT and DUCKDB_THREADS
- Graceful shutdown wired to process signals
- MCP server still starts and operates normally
</success_criteria>

<output>
After completion, create `.planning/phases/41-database-infrastructure/41-01-SUMMARY.md`
</output>
