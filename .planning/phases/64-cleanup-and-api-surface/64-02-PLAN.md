---
phase: 64-cleanup-and-api-surface
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/spx-daily.pine
  - scripts/spx-15min-checkpoints.pine
  - scripts/vix-intraday.pine
  - packages/mcp-server/src/utils/market-importer.ts
autonomous: true
requirements: [CLN-05, CLN-06]

must_haves:
  truths:
    - "A single universal Pine Script works on any chart timeframe, exporting raw OHLCV plus VIX term structure data"
    - "The two obsolete Pine Scripts (spx-15min-checkpoints.pine, vix-intraday.pine) are deleted"
    - "import_market_csv can import intraday CSVs with a single Unix timestamp 'time' column into market.intraday by auto-splitting into date (YYYY-MM-DD) and time (HH:MM) columns"
  artifacts:
    - path: "scripts/spx-daily.pine"
      provides: "Universal market data export script for any TradingView timeframe"
      contains: "request.security"
    - path: "packages/mcp-server/src/utils/market-importer.ts"
      provides: "Extended applyColumnMapping that splits Unix timestamps into date+time for intraday imports"
      contains: "parseFlexibleTime"
  key_links:
    - from: "scripts/spx-daily.pine"
      to: "packages/mcp-server/src/utils/market-importer.ts"
      via: "CSV export → import_market_csv column mapping"
      pattern: "columnMapping.*time"
---

<objective>
Simplify Pine Scripts from 3 to 1 universal script and extend the market importer to split Unix timestamps into separate date and time columns for intraday imports.

Purpose: The old 3-script approach required users to run different scripts on different chart timeframes and manage multiple CSV files. The new universal script works on any timeframe (daily or intraday), exporting only raw OHLCV data since the enrichment pipeline now computes all derived fields. Extending the importer to split timestamps resolves the intraday import blocker documented in STATE.md.

Output: One universal Pine Script, two deleted scripts, and an importer that handles intraday CSV imports seamlessly.
</objective>

<execution_context>
@/Users/davidromeo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidromeo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/64-cleanup-and-api-surface/64-RESEARCH.md

Key references:
@scripts/spx-daily.pine (current daily script — will be replaced with universal script)
@scripts/spx-15min-checkpoints.pine (to delete — CLN-06)
@scripts/vix-intraday.pine (to delete — CLN-06)
@packages/mcp-server/src/utils/market-importer.ts (applyColumnMapping at line 161, parseFlexibleDate at line 128)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend market-importer.ts to split Unix timestamps into date + time for intraday imports</name>
  <files>packages/mcp-server/src/utils/market-importer.ts</files>
  <action>
The STATE.md blocker states: "column mapping cannot split one source column into two." This task resolves that by teaching `applyColumnMapping` to extract both `date` and `time` from a single Unix timestamp source column when the target is `market.intraday`.

1. Add a `parseFlexibleTime` function near `parseFlexibleDate`:
```typescript
/**
 * Extract HH:MM time from a Unix timestamp (seconds) in Eastern Time.
 * Returns null if value is not a valid Unix timestamp.
 */
function parseFlexibleTime(value: string): string | null {
  const numeric = Number(value);
  if (!isNaN(numeric) && numeric > 1e8) {
    // Unix timestamp in seconds — convert to Eastern Time HH:MM
    const d = new Date(numeric * 1000);
    return d.toLocaleTimeString("en-US", {
      timeZone: "America/New_York",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false,
    }); // Returns "HH:MM" format
  }
  // If already in HH:MM format, return as-is
  if (/^\d{2}:\d{2}$/.test(value)) {
    return value;
  }
  // If in HHMM format (4 digits), convert to HH:MM
  if (/^\d{4}$/.test(value)) {
    return `${value.slice(0, 2)}:${value.slice(2)}`;
  }
  return null;
}
```

2. In `applyColumnMapping`, add handling for the `time` schema column. Currently, only `date` has special parsing (line 177). Add a similar branch for `time`:
```typescript
} else if (schemaCol === "time") {
  const parsedTime = parseFlexibleTime(rawValue);
  if (parsedTime === null) {
    console.warn(`[market-importer] Skipping row with unparseable time value: "${rawValue}"`);
    hasNullDate = true; // Reuse the skip mechanism
    break;
  }
  mapped[schemaCol] = parsedTime;
}
```

3. **Critical: Support mapping the same source column to both `date` and `time`.** When a user's column mapping has `{ "time": "date", "time": "time" }` — wait, that's the same key. Instead, the pattern is: the CSV has a `time` column (Unix timestamp). The column mapping would be:
   ```json
   { "time": "date", "time": "time" }
   ```
   But JS objects can't have duplicate keys. So the approach is different: allow a **special source column prefix** convention. Actually, the simpler approach is:

   In `applyColumnMapping`, when `targetTable === "intraday"` and the mapped row has a `date` but no `time`, AND the source value that produced `date` was a Unix timestamp (numeric > 1e8), ALSO extract the time automatically:

   After the main mapping loop, add:
   ```typescript
   // Auto-extract time from date's Unix timestamp for intraday imports
   if (targetTable === "intraday" && mapped.date && !mapped.time) {
     // Find the source column that mapped to "date"
     const dateSourceCol = Object.entries(columnMapping).find(([_, schema]) => schema === "date")?.[0];
     if (dateSourceCol) {
       const rawDateValue = row[dateSourceCol] ?? "";
       const numericDate = Number(rawDateValue);
       if (!isNaN(numericDate) && numericDate > 1e8) {
         // Same Unix timestamp — extract time component
         const parsedTime = parseFlexibleTime(rawDateValue);
         if (parsedTime) {
           mapped.time = parsedTime;
         }
       }
     }
   }
   ```

   This way, a user importing intraday data with a single `time` (Unix) column just maps `{ "time": "date" }` and the `time` (HH:MM) column is auto-populated. The user can also explicitly map a separate source column to `time` if the CSV has separate date and time columns.

4. Update the `REQUIRED_SCHEMA_FIELDS` validation to NOT require `time` as a mapped column for intraday IF the date column is being mapped from a Unix timestamp (the auto-extract will provide it). The simplest approach: move the validation to AFTER `applyColumnMapping` instead of before, checking that the mapped rows actually have all required fields. Or: keep the validation as-is but note in the tool description that for intraday imports with a single Unix `time` column, mapping it to `date` will auto-extract the `time` component.

   Actually, the validation at the tool level (in `market-imports.ts`) checks that the column mapping contains entries for all required schema fields. For intraday, this requires `date`, `time`, `open`, `high`, `low`, `close`. The user would need to provide a mapping for `time` explicitly. The cleaner approach: allow the mapping validation to pass if `targetTable === "intraday"` and `date` is mapped but `time` is not — with a note that time will be auto-derived from Unix timestamps. Check where the validation happens:

   In `market-imports.ts`, the tool validates `columnMapping` has all required fields per `REQUIRED_SCHEMA_FIELDS`. Adjust the intraday validation: if `time` is not in the mapping values but `date` IS, allow it with a note that time will be auto-derived. Add this as a special case in the validation logic.

5. Update the `import_market_csv` and `import_from_database` tool descriptions to mention that for intraday imports, if the source has a single Unix timestamp column, mapping it to `date` will auto-extract the `time` (HH:MM ET) component.
  </action>
  <verify>
1. `cd packages/mcp-server && npx tsc --noEmit` — no TypeScript errors
2. Verify `parseFlexibleTime` handles: Unix timestamps (returns HH:MM ET), HH:MM strings (pass-through), HHMM strings (converts to HH:MM)
3. Build succeeds: `cd packages/mcp-server && npm run build`
  </verify>
  <done>market-importer.ts auto-extracts HH:MM time from Unix timestamps for intraday imports; users can import intraday CSVs by mapping a single `time` column to `date` and getting `time` auto-populated; validation allows missing `time` mapping for intraday when `date` is mapped to a Unix timestamp source</done>
</task>

<task type="auto">
  <name>Task 2: Replace 3 Pine Scripts with 1 universal script</name>
  <files>
    scripts/spx-daily.pine
    scripts/spx-15min-checkpoints.pine
    scripts/vix-intraday.pine
  </files>
  <action>
1. **Delete** `scripts/spx-15min-checkpoints.pine` (CLN-06)
2. **Delete** `scripts/vix-intraday.pine` (CLN-06)

3. **Replace** `scripts/spx-daily.pine` with a new universal script. The file name stays the same (it's the convention). The new script:

```pine
//@version=6
indicator("TradeBlocks Market Data Export", overlay=false)

// =============================================================================
// UNIVERSAL MARKET DATA EXPORT
// =============================================================================
// Purpose: Export raw OHLCV + VIX term structure for import into TradeBlocks
//
// Usage:
//   1. Apply to ANY chart on ANY timeframe
//      - Daily chart → import to market.daily via import_market_csv
//      - Intraday chart (5m, 15m, etc.) → import to market.intraday
//   2. Set date range in TradingView
//   3. Right-click indicator pane -> "Export chart data..."
//   4. Import via: import_market_csv with column mapping
//
// Column mapping examples:
//   Daily:    { "time": "date", "open": "open", "high": "high", "low": "low", "close": "close" }
//   Context:  { "time": "date", "VIX_Open": "VIX_Open", "VIX_Close": "VIX_Close", ... }
//   Intraday: { "time": "date", "open": "open", "high": "high", "low": "low", "close": "close" }
//             (time HH:MM auto-extracted from Unix timestamp for intraday imports)
//
// Note: Enrichment pipeline computes all derived fields (RSI, ATR, Bollinger, etc.)
//       from raw OHLCV after import — no need to export them from TradingView.
// =============================================================================

// VIX term structure via request.security (returns na on intraday timeframes — safe to export)
float vixOpen    = request.security("CBOE:VIX",   timeframe.period, open)
float vixHigh    = request.security("CBOE:VIX",   timeframe.period, high)
float vixLow     = request.security("CBOE:VIX",   timeframe.period, low)
float vixClose   = request.security("CBOE:VIX",   timeframe.period, close)
float vix9dClose = request.security("CBOE:VIX9D", timeframe.period, close)
float vix3mClose = request.security("CBOE:VIX3M", timeframe.period, close)

// Export raw OHLCV (TradingView includes open/high/low/close as default columns
// in the export, but we plot them explicitly for clear column mapping)
plot(open,  "open",  display=display.data_window)
plot(high,  "high",  display=display.data_window)
plot(low,   "low",   display=display.data_window)
plot(close, "close", display=display.data_window)

// VIX data plots (daily timeframe: real values; intraday: na — harmless in export)
plot(vixOpen,    "VIX_Open",    display=display.data_window)
plot(vixHigh,    "VIX_High",    display=display.data_window)
plot(vixLow,     "VIX_Low",     display=display.data_window)
plot(vixClose,   "VIX_Close",   display=display.data_window)
plot(vix9dClose, "VIX9D_Close", display=display.data_window)
plot(vix3mClose, "VIX3M_Close", display=display.data_window)
```

This script:
- Works on ANY timeframe (daily for market.daily, intraday for market.intraday)
- Exports only raw OHLCV + VIX term structure (~10 columns total)
- No derived fields (RSI, ATR, Bollinger, etc.) — enrichment pipeline computes those
- VIX `request.security()` calls return `na` on intraday timeframes (exported as empty/NaN — harmless)
- No visual elements (hlines, bgcolor) needed — this is a data export tool
- Import column mapping handles all the heavy lifting (Unix timestamp → date + time, ticker normalization)

The column count is ~10 export plots (open, high, low, close, VIX_Open, VIX_High, VIX_Low, VIX_Close, VIX9D_Close, VIX3M_Close) plus TradingView's default `time` column — well within the "~12 columns" target from CLN-05.
  </action>
  <verify>
1. Verify `scripts/spx-15min-checkpoints.pine` does not exist
2. Verify `scripts/vix-intraday.pine` does not exist
3. Verify `scripts/spx-daily.pine` exists and contains "TradeBlocks Market Data Export"
4. Count export plots in spx-daily.pine: should be approximately 10 (open, high, low, close + 6 VIX fields)
  </verify>
  <done>3 Pine Scripts replaced by 1 universal script; spx-15min-checkpoints.pine and vix-intraday.pine are deleted; the universal script exports raw OHLCV + VIX term structure (~10 columns) and works on any timeframe</done>
</task>

</tasks>

<verification>
1. `scripts/spx-daily.pine` exists with universal script content
2. `scripts/spx-15min-checkpoints.pine` and `scripts/vix-intraday.pine` do not exist
3. `cd packages/mcp-server && npm run build` — clean build
4. `parseFlexibleTime` correctly extracts HH:MM ET from Unix timestamps
</verification>

<success_criteria>
- Only 1 Pine Script file exists in scripts/ (spx-daily.pine with universal content)
- The universal script exports raw OHLCV + VIX (~10 columns), no derived fields
- market-importer.ts can auto-extract time (HH:MM) from Unix timestamps for intraday imports
- The STATE.md intraday import blocker is resolved by the importer extension
- Build succeeds cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/64-cleanup-and-api-surface/64-02-SUMMARY.md`
</output>
