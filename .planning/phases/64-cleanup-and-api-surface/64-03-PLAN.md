---
phase: 64-cleanup-and-api-surface
plan: 03
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - packages/mcp-server/src/utils/market-enricher.ts
  - packages/mcp-server/src/db/market-schemas.ts
  - packages/mcp-server/tests/unit/tier3-enrichment.test.ts
  # Note: test-exports.ts edit consolidated into Plan 64-01 to avoid parallel file conflict
autonomous: true
requirements: [ENR-04]

must_haves:
  truths:
    - "Tier 3 enrichment computes all 5 fields (High_Time, Low_Time, High_Before_Low, Reversal_Type, Opening_Drive_Strength, Intraday_Realized_Vol) from market.intraday bars and writes them to market.daily"
    - "Opening_Drive_Strength and Intraday_Realized_Vol columns exist in the market.daily schema"
    - "Tier 3 gracefully skips when no intraday data exists (returns status: 'skipped' with actionable message)"
    - "Re-running enrichment with Tier 3 data produces identical results (idempotent)"
  artifacts:
    - path: "packages/mcp-server/src/utils/market-enricher.ts"
      provides: "runTier3 function computing 6 intraday timing fields from raw OHLCV bars"
      contains: "runTier3"
    - path: "packages/mcp-server/src/db/market-schemas.ts"
      provides: "market.daily schema with Opening_Drive_Strength and Intraday_Realized_Vol columns"
      contains: "Opening_Drive_Strength"
    - path: "packages/mcp-server/tests/unit/tier3-enrichment.test.ts"
      provides: "Unit tests for Tier 3 computation logic covering all 5 output fields"
      contains: "computeIntradayTimingFields"
  key_links:
    - from: "packages/mcp-server/src/utils/market-enricher.ts"
      to: "market.intraday"
      via: "SQL query for raw bars grouped by date"
      pattern: "FROM market.intraday"
---

<objective>
Implement Tier 3 enrichment that computes all 5 intraday timing fields (High_Time, Low_Time, High_Before_Low, Reversal_Type, Opening_Drive_Strength, Intraday_Realized_Vol) from market.intraday bars, add missing schema columns, and write results to market.daily.

Purpose: Tier 3 enrichment was blocked by the intraday CSV format incompatibility (STATE.md blocker). Now that Pine Script simplification and importer time-splitting resolve the blocker, the actual computation logic can be implemented. These fields tell traders when the day's high and low occurred, whether the day showed a reversal pattern, how strong the opening drive was, and the realized intraday volatility — critical for understanding intraday price action.

Output: Working Tier 3 enrichment in market-enricher.ts with schema migration and unit tests for the pure computation logic.
</objective>

<execution_context>
@/Users/davidromeo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidromeo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/64-cleanup-and-api-surface/64-RESEARCH.md
@.planning/phases/62-typescript-enrichment-pipeline/62-02-SUMMARY.md

Key references:
@packages/mcp-server/src/utils/market-enricher.ts (hasTier3Data at line 667, hard-skip at line 897-909, batchUpdateDaily helper, TierStatus type)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add schema columns and implement Tier 3 enrichment in market-enricher.ts</name>
  <files>
    packages/mcp-server/src/db/market-schemas.ts
    packages/mcp-server/src/utils/market-enricher.ts
  </files>
  <action>
**Scope:** Implement all 5 Tier 3 fields per user decision: `High_Time`, `Low_Time`, `High_Before_Low`, `Reversal_Type`, `Opening_Drive_Strength`, `Intraday_Realized_Vol`. Two of these fields (`Opening_Drive_Strength`, `Intraday_Realized_Vol`) require schema migration.

**Step 0: Add schema columns to market-schemas.ts**

In `packages/mcp-server/src/db/market-schemas.ts`, add `Opening_Drive_Strength` and `Intraday_Realized_Vol` columns to the `market.daily` CREATE TABLE statement, in the Tier 3 section alongside the existing 4 fields:

```sql
      -- Tier 3 intraday timing
      High_Time DOUBLE,
      Low_Time DOUBLE,
      High_Before_Low INTEGER,
      Reversal_Type INTEGER,
      Opening_Drive_Strength DOUBLE,
      Intraday_Realized_Vol DOUBLE,
```

Since `CREATE TABLE IF NOT EXISTS` won't add new columns to an existing table, add a migration block (similar to the existing Trend_Score migration) AFTER the CREATE TABLE:

```typescript
  // Migration: add Tier 3 columns that were added after initial schema
  for (const col of [
    { name: "Opening_Drive_Strength", type: "DOUBLE" },
    { name: "Intraday_Realized_Vol", type: "DOUBLE" },
  ]) {
    try {
      await conn.run(`ALTER TABLE market.daily ADD COLUMN ${col.name} ${col.type}`);
    } catch {
      // Column already exists — ignore
    }
  }
```

Place this migration AFTER the existing Trend_Score drop migration block (around line 76).

**Step 1: Add pure computation function** (exported, for testing):

```typescript
/**
 * Compute intraday timing fields from raw OHLCV bars for a single date.
 *
 * @param bars - Array of {time: "HH:MM", open: number, high: number, low: number, close: number} ordered by time
 * @param dailyOpen - The daily open price (first bar's open), used for Opening_Drive_Strength
 * @returns computed fields or null if bars is empty
 */
export function computeIntradayTimingFields(
  bars: Array<{ time: string; open: number; high: number; low: number; close: number }>
): {
  highTime: number;              // Decimal hours (e.g., 10.5 = 10:30)
  lowTime: number;               // Decimal hours
  highBeforeLow: boolean;        // true if high occurred before low
  reversalType: number;          // +1 = morning high + afternoon low, -1 = morning low + afternoon high, 0 = trend day
  openingDriveStrength: number;  // (first 30min range) / (full day range), 0-1 scale; NaN if day range is 0
  intradayRealizedVol: number;   // Annualized realized vol from intraday bar-to-bar log returns
} | null {
  if (bars.length === 0) return null;

  let maxHigh = -Infinity;
  let minLow = Infinity;
  let highTimeStr = bars[0].time;
  let lowTimeStr = bars[0].time;

  for (const bar of bars) {
    if (bar.high > maxHigh) {
      maxHigh = bar.high;
      highTimeStr = bar.time;
    }
    if (bar.low < minLow) {
      minLow = bar.low;
      lowTimeStr = bar.time;
    }
  }

  const highTime = hhmmToDecimalHours(highTimeStr);
  const lowTime = hhmmToDecimalHours(lowTimeStr);
  const highBeforeLow = highTime < lowTime;

  // Reversal type: morning = before 12:00, afternoon = 12:00 or later
  const highInMorning = highTime < 12;
  const lowInMorning = lowTime < 12;
  const highInAfternoon = highTime >= 12;
  const lowInAfternoon = lowTime >= 12;

  let reversalType = 0;
  if (highInMorning && lowInAfternoon) reversalType = 1;    // High morning, low afternoon
  else if (lowInMorning && highInAfternoon) reversalType = -1; // Low morning, high afternoon

  // Opening Drive Strength: ratio of first-30-min range to full-day range
  // First 30 min = bars with time < 10:00 (market opens 09:30)
  const openingBars = bars.filter(b => hhmmToDecimalHours(b.time) < 10);
  let openingDriveStrength = 0;
  const fullDayRange = maxHigh - minLow;
  if (openingBars.length > 0 && fullDayRange > 0) {
    const openHigh = Math.max(...openingBars.map(b => b.high));
    const openLow = Math.min(...openingBars.map(b => b.low));
    openingDriveStrength = (openHigh - openLow) / fullDayRange;
  }

  // Intraday Realized Vol: annualized from bar-to-bar close log returns
  // Uses sqrt(252 * barsPerDay) annualization
  let intradayRealizedVol = 0;
  if (bars.length >= 2) {
    const logReturns: number[] = [];
    for (let i = 1; i < bars.length; i++) {
      if (bars[i - 1].close > 0 && bars[i].close > 0) {
        logReturns.push(Math.log(bars[i].close / bars[i - 1].close));
      }
    }
    if (logReturns.length > 0) {
      const mean = logReturns.reduce((s, r) => s + r, 0) / logReturns.length;
      const variance = logReturns.reduce((s, r) => s + (r - mean) ** 2, 0) / logReturns.length;
      const barStdDev = Math.sqrt(variance);
      // Annualize: multiply by sqrt(barsPerDay * 252)
      // barsPerDay = number of bars we actually have (adapts to timeframe)
      intradayRealizedVol = barStdDev * Math.sqrt(bars.length * 252);
    }
  }

  return { highTime, lowTime, highBeforeLow, reversalType, openingDriveStrength, intradayRealizedVol };
}

function hhmmToDecimalHours(time: string): number {
  const [h, m] = time.split(':').map(Number);
  return h + m / 60;
}
```

**Step 2: Add `runTier3` function** following the same pattern as `runTier2`:

```typescript
async function runTier3(
  conn: DuckDBConnection,
  ticker: string,
  dates: string[]
): Promise<TierStatus> {
  // Check if intraday data exists for this ticker
  const hasData = await hasTier3Data(conn, ticker);
  if (!hasData) {
    return {
      status: "skipped",
      reason: "no intraday data in market.intraday — import intraday bars to populate Tier 3 fields",
    };
  }

  // Query intraday bars for all dates in the enrichment range
  const result = await conn.runAndReadAll(
    `SELECT date, time, open, high, low, close
     FROM market.intraday
     WHERE ticker = $1 AND date >= $2 AND date <= $3
     ORDER BY date, time`,
    [ticker, dates[0], dates[dates.length - 1]]
  );

  const rows = result.getRows();
  const columns = result.columnNames();
  const dateIdx = columns.indexOf("date");
  const timeIdx = columns.indexOf("time");
  const openIdx = columns.indexOf("open");
  const highIdx = columns.indexOf("high");
  const lowIdx = columns.indexOf("low");
  const closeIdx = columns.indexOf("close");

  // Group bars by date
  const barsByDate = new Map<string, Array<{ time: string; open: number; high: number; low: number; close: number }>>();
  for (const row of rows) {
    const dateStr = String(row[dateIdx]);
    const bar = {
      time: String(row[timeIdx]),
      open: Number(row[openIdx]),
      high: Number(row[highIdx]),
      low: Number(row[lowIdx]),
      close: Number(row[closeIdx]),
    };
    if (!barsByDate.has(dateStr)) barsByDate.set(dateStr, []);
    barsByDate.get(dateStr)!.push(bar);
  }

  if (barsByDate.size === 0) {
    return {
      status: "skipped",
      reason: "intraday data exists but no bars overlap with enrichment date range",
    };
  }

  // Compute timing fields for each date and batch update market.daily
  const tier3Cols = ["High_Time", "Low_Time", "High_Before_Low", "Reversal_Type", "Opening_Drive_Strength", "Intraday_Realized_Vol"];
  const enrichedRows: Array<{ date: string; values: Record<string, unknown> }> = [];

  for (const [dateStr, bars] of barsByDate) {
    const timing = computeIntradayTimingFields(bars);
    if (!timing) continue;

    enrichedRows.push({
      date: dateStr,
      values: {
        High_Time: timing.highTime,
        Low_Time: timing.lowTime,
        High_Before_Low: timing.highBeforeLow ? 1 : 0,
        Reversal_Type: timing.reversalType,
        Opening_Drive_Strength: timing.openingDriveStrength,
        Intraday_Realized_Vol: timing.intradayRealizedVol,
      },
    });
  }

  // Batch update using the existing batchUpdateDaily helper
  const BATCH_SIZE = 500;
  const updateRows = enrichedRows.map(r => ({ date: r.date, ticker, ...r.values }));
  for (let start = 0; start < updateRows.length; start += BATCH_SIZE) {
    const batch = updateRows.slice(start, start + BATCH_SIZE);
    await batchUpdateDaily(conn, batch, tier3Cols);
  }

  return { status: "complete", fieldsWritten: tier3Cols.length };
}
```

Note: Check how `batchUpdateDaily` accepts rows. Match the existing pattern from Tier 1 enrichment (look at how `enrichedRows` is structured before being passed to `batchUpdateDaily` — around line 888).

**Step 3: Replace the hard-skip at lines 897-909** with actual `runTier3` call:
```typescript
  // 10. Tier 3 — intraday timing fields from market.intraday
  const tier3Result = await runTier3(conn, ticker, dates);
```

Remove the old `hasTier3` variable and the old `tier3Result` ternary (lines 898-909). The `hasTier3Data` function at line 667 stays — it's called inside `runTier3` now.

**Step 4: Update the enricher JSDoc** (lines 690-692): Remove the "Schema gaps" comment entirely. Replace with a note that Tier 3 writes 6 fields: `High_Time`, `Low_Time`, `High_Before_Low`, `Reversal_Type`, `Opening_Drive_Strength`, `Intraday_Realized_Vol`.

**Step 5: Export `computeIntradayTimingFields`** from the module (add `export` keyword to the function declaration). The `test-exports.ts` entry is handled by Plan 64-01 Task 1 — do NOT modify `test-exports.ts` in this plan.
  </action>
  <verify>
1. `cd packages/mcp-server && npx tsc --noEmit` — no TypeScript errors
2. `cd packages/mcp-server && npm run build` — build succeeds
3. `grep -n "runTier3" packages/mcp-server/src/utils/market-enricher.ts` — function exists
4. `grep -n "computeIntradayTimingFields" packages/mcp-server/src/utils/market-enricher.ts` — exported function exists
5. Verify the hard-skip at line 897 is replaced with `runTier3` call
6. `grep -n "Opening_Drive_Strength\|Intraday_Realized_Vol" packages/mcp-server/src/db/market-schemas.ts` — both columns present in schema
  </verify>
  <done>Schema migration adds Opening_Drive_Strength and Intraday_Realized_Vol columns; Tier 3 enrichment reads bars from market.intraday, computes all 6 fields (High_Time/Low_Time/High_Before_Low/Reversal_Type/Opening_Drive_Strength/Intraday_Realized_Vol) via pure computeIntradayTimingFields function, and batch-updates market.daily; gracefully skips when no intraday data exists</done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for Tier 3 computation logic</name>
  <files>
    packages/mcp-server/tests/unit/tier3-enrichment.test.ts
  </files>
  <action>
**Note:** The `computeIntradayTimingFields` export in `test-exports.ts` is handled by Plan 64-01 Task 1 (which consolidates all test-exports.ts edits). This task only creates the test file — the export will already exist when this task runs (Plan 64-01 is wave 1, this plan is wave 2).

1. **Create** `packages/mcp-server/tests/unit/tier3-enrichment.test.ts` with the following test cases. Note: bars now require `open` and `close` fields since `computeIntradayTimingFields` uses them for Opening_Drive_Strength and Intraday_Realized_Vol.

```typescript
import { computeIntradayTimingFields } from "../../dist/test-exports.js";

describe("computeIntradayTimingFields", () => {
  // Helper to create a bar with all required fields
  const bar = (time: string, open: number, high: number, low: number, close: number) =>
    ({ time, open, high, low, close });

  it("returns null for empty bars array", () => {
    expect(computeIntradayTimingFields([])).toBeNull();
  });

  it("computes High_Time and Low_Time in decimal hours", () => {
    const bars = [
      bar("09:30", 99, 100, 99, 99.5),
      bar("10:00", 99, 102, 98, 101),     // Highest high
      bar("14:30", 100, 101, 97, 98),     // Lowest low
      bar("15:45", 99, 100.5, 99, 100),
    ];
    const result = computeIntradayTimingFields(bars)!;
    expect(result.highTime).toBe(10);        // 10:00 = 10.0 decimal hours
    expect(result.lowTime).toBe(14.5);       // 14:30 = 14.5 decimal hours
  });

  it("detects highBeforeLow when high occurs earlier", () => {
    const bars = [
      bar("09:30", 100, 105, 100, 103),   // High of day
      bar("15:00", 100, 101, 96, 98),     // Low of day
    ];
    const result = computeIntradayTimingFields(bars)!;
    expect(result.highBeforeLow).toBe(true);
  });

  it("detects highBeforeLow=false when low occurs earlier", () => {
    const bars = [
      bar("09:30", 100, 100, 95, 98),     // Low of day
      bar("15:00", 100, 106, 100, 104),   // High of day
    ];
    const result = computeIntradayTimingFields(bars)!;
    expect(result.highBeforeLow).toBe(false);
  });

  it("reversalType = +1 when high in morning, low in afternoon", () => {
    const bars = [
      bar("10:00", 108, 110, 105, 107),   // Morning high of day
      bar("14:00", 100, 104, 98, 99),     // Afternoon low of day
    ];
    const result = computeIntradayTimingFields(bars)!;
    expect(result.reversalType).toBe(1);
  });

  it("reversalType = -1 when low in morning, high in afternoon", () => {
    const bars = [
      bar("10:00", 98, 100, 95, 97),      // Morning low of day
      bar("14:00", 104, 108, 100, 106),   // Afternoon high of day
    ];
    const result = computeIntradayTimingFields(bars)!;
    expect(result.reversalType).toBe(-1);
  });

  it("reversalType = 0 for trend day (both extremes in morning)", () => {
    const bars = [
      bar("09:30", 98, 100, 95, 99),      // Low of day (morning)
      bar("11:00", 102, 108, 100, 106),   // High of day (morning)
      bar("14:00", 104, 106, 99, 102),
    ];
    const result = computeIntradayTimingFields(bars)!;
    expect(result.reversalType).toBe(0);
  });

  it("reversalType = 0 for trend day (both extremes in afternoon)", () => {
    const bars = [
      bar("09:30", 101, 102, 100, 101),
      bar("13:00", 100, 105, 97, 100),    // Low of day (afternoon)
      bar("15:00", 104, 110, 100, 108),   // High of day (afternoon)
    ];
    const result = computeIntradayTimingFields(bars)!;
    expect(result.reversalType).toBe(0);
  });

  it("handles single bar (edge case)", () => {
    const bars = [bar("12:00", 97, 100, 95, 98)];
    const result = computeIntradayTimingFields(bars)!;
    expect(result.highTime).toBe(12);
    expect(result.lowTime).toBe(12);
    expect(result.highBeforeLow).toBe(false); // Same time, not "before"
    expect(result.reversalType).toBe(0);       // Same bar, no reversal
    expect(result.openingDriveStrength).toBe(0); // No opening bars (12:00 >= 10:00)
    expect(result.intradayRealizedVol).toBe(0);  // Single bar, no returns
  });

  it("uses first occurrence when multiple bars share the same extreme", () => {
    const bars = [
      bar("10:00", 102, 105, 100, 103),
      bar("14:00", 102, 105, 100, 103),   // Same high and low
    ];
    const result = computeIntradayTimingFields(bars)!;
    // First occurrence wins (strict > / < comparison)
    expect(result.highTime).toBe(10);
    expect(result.lowTime).toBe(10);
  });

  describe("openingDriveStrength", () => {
    it("computes ratio of first-30-min range to full-day range", () => {
      const bars = [
        bar("09:30", 100, 103, 99, 102),    // Opening bar: range = 103 - 99 = 4
        bar("09:45", 102, 104, 100, 103),    // Opening bar: high=104, low pushed to 99 by first bar
        bar("10:00", 103, 106, 98, 105),     // NOT opening (>= 10:00)
        bar("14:00", 104, 107, 96, 100),     // Extends day range
      ];
      const result = computeIntradayTimingFields(bars)!;
      // Opening bars (< 10:00): 09:30 and 09:45 → high=104, low=99, range=5
      // Full day: high=107, low=96, range=11
      expect(result.openingDriveStrength).toBeCloseTo(5 / 11, 6);
    });

    it("returns 0 when no bars in opening period", () => {
      const bars = [
        bar("10:00", 100, 102, 99, 101),
        bar("14:00", 100, 105, 97, 103),
      ];
      const result = computeIntradayTimingFields(bars)!;
      expect(result.openingDriveStrength).toBe(0);
    });

    it("returns 0 when full day range is 0 (flat day)", () => {
      const bars = [
        bar("09:30", 100, 100, 100, 100),
        bar("10:00", 100, 100, 100, 100),
      ];
      const result = computeIntradayTimingFields(bars)!;
      expect(result.openingDriveStrength).toBe(0);
    });
  });

  describe("intradayRealizedVol", () => {
    it("computes annualized vol from bar-to-bar close log returns", () => {
      // 4 bars with known closes: 100, 101, 99, 100
      const bars = [
        bar("09:30", 100, 101, 99, 100),
        bar("10:00", 100, 102, 100, 101),
        bar("10:30", 101, 101, 98, 99),
        bar("11:00", 99, 101, 99, 100),
      ];
      const result = computeIntradayTimingFields(bars)!;
      // Should be > 0 (annualized vol from 3 log returns across 4 bars * 252 days)
      expect(result.intradayRealizedVol).toBeGreaterThan(0);
      // Sanity check: not unreasonably large (< 200% annualized for this data)
      expect(result.intradayRealizedVol).toBeLessThan(2);
    });

    it("returns 0 for single bar (no returns)", () => {
      const bars = [bar("09:30", 100, 102, 99, 101)];
      const result = computeIntradayTimingFields(bars)!;
      expect(result.intradayRealizedVol).toBe(0);
    });

    it("returns 0 when all closes are identical (no volatility)", () => {
      const bars = [
        bar("09:30", 100, 102, 99, 100),
        bar("10:00", 100, 101, 99, 100),
        bar("10:30", 100, 103, 98, 100),
      ];
      const result = computeIntradayTimingFields(bars)!;
      expect(result.intradayRealizedVol).toBe(0);
    });
  });
});
```

2. Run the build first (`cd packages/mcp-server && npm run build`), then run the tests (`npm test -- tests/unit/tier3-enrichment.test.ts`).
  </action>
  <verify>
1. `cd packages/mcp-server && npm run build` — build succeeds (needed for dist/test-exports.js)
2. `npm test -- tests/unit/tier3-enrichment.test.ts` — all tests pass
3. `grep -n "computeIntradayTimingFields" packages/mcp-server/src/test-exports.ts` — export exists (added by Plan 64-01)
  </verify>
  <done>Unit tests for computeIntradayTimingFields cover: empty input, decimal hour conversion, highBeforeLow detection, all three reversalType values (+1, -1, 0), single bar edge case, tied extremes, openingDriveStrength (ratio, no-opening-bars, flat-day), and intradayRealizedVol (annualized vol, single bar, identical closes); all tests pass</done>
</task>

</tasks>

<verification>
1. `cd packages/mcp-server && npm run build` — clean build
2. `npm test -- tests/unit/tier3-enrichment.test.ts` — all Tier 3 tests pass
3. `grep -n "always skipped" packages/mcp-server/src/utils/market-enricher.ts` — returns no results (hard-skip removed)
4. `grep -n "runTier3" packages/mcp-server/src/utils/market-enricher.ts` — function exists and is called
5. `grep -n "Opening_Drive_Strength\|Intraday_Realized_Vol" packages/mcp-server/src/db/market-schemas.ts` — both columns present
</verification>

<success_criteria>
- Schema migration adds Opening_Drive_Strength (DOUBLE) and Intraday_Realized_Vol (DOUBLE) columns to market.daily
- Tier 3 enrichment computes all 6 fields: High_Time, Low_Time, High_Before_Low, Reversal_Type, Opening_Drive_Strength, Intraday_Realized_Vol from market.intraday
- Tier 3 gracefully skips when no intraday data exists (status: "skipped")
- computeIntradayTimingFields has comprehensive unit tests (14+ test cases covering all 5 output field groups)
- Build succeeds and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/64-cleanup-and-api-surface/64-03-SUMMARY.md`
</output>
