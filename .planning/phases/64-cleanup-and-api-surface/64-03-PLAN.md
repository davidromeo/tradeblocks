---
phase: 64-cleanup-and-api-surface
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mcp-server/src/utils/market-enricher.ts
  - packages/mcp-server/tests/unit/tier3-enrichment.test.ts
  # Note: test-exports.ts edit consolidated into Plan 64-01 to avoid parallel file conflict
autonomous: true
requirements: [ENR-04]

must_haves:
  truths:
    - "Tier 3 enrichment computes High_Time, Low_Time, High_Before_Low, and Reversal_Type from market.intraday bars and writes them to market.daily"
    - "Tier 3 gracefully skips when no intraday data exists (returns status: 'skipped' with actionable message)"
    - "Re-running enrichment with Tier 3 data produces identical results (idempotent)"
  artifacts:
    - path: "packages/mcp-server/src/utils/market-enricher.ts"
      provides: "runTier3 function computing 4 intraday timing fields from raw OHLCV bars"
      contains: "runTier3"
    - path: "packages/mcp-server/tests/unit/tier3-enrichment.test.ts"
      provides: "Unit tests for Tier 3 computation logic"
      contains: "computeIntradayTimingFields"
  key_links:
    - from: "packages/mcp-server/src/utils/market-enricher.ts"
      to: "market.intraday"
      via: "SQL query for raw bars grouped by date"
      pattern: "FROM market.intraday"
---

<objective>
Implement Tier 3 enrichment that computes intraday timing fields (High_Time, Low_Time, High_Before_Low, Reversal_Type) from market.intraday bars and writes them to market.daily.

Purpose: Tier 3 enrichment was blocked by the intraday CSV format incompatibility (STATE.md blocker). Now that Pine Script simplification and importer time-splitting resolve the blocker, the actual computation logic can be implemented. These fields tell traders when the day's high and low occurred and whether the day showed a reversal pattern — critical for understanding intraday price action.

Output: Working Tier 3 enrichment in market-enricher.ts with unit tests for the pure computation logic.
</objective>

<execution_context>
@/Users/davidromeo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidromeo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/64-cleanup-and-api-surface/64-RESEARCH.md
@.planning/phases/62-typescript-enrichment-pipeline/62-02-SUMMARY.md

Key references:
@packages/mcp-server/src/utils/market-enricher.ts (hasTier3Data at line 667, hard-skip at line 897-909, batchUpdateDaily helper, TierStatus type)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Tier 3 enrichment in market-enricher.ts</name>
  <files>packages/mcp-server/src/utils/market-enricher.ts</files>
  <action>
**Scope:** Implement only the 4 existing schema columns: `High_Time`, `Low_Time`, `High_Before_Low`, `Reversal_Type`. Do NOT implement `Opening_Drive_Strength` or `Intraday_Realized_Vol` — these columns do NOT exist in `market-schemas.ts` (`CREATE TABLE market.daily` has no such columns) and are documented as schema gaps in the enricher's header comment (lines 691-692). CONTEXT.md lists 5 Tier 3 fields but 2 require a schema migration (adding columns to market.daily) before they can be implemented — that is out of scope for this phase.

1. **Add a pure computation function** (exported, for testing):
```typescript
/**
 * Compute intraday timing fields from raw OHLCV bars for a single date.
 *
 * @param bars - Array of {time: "HH:MM", high: number, low: number} ordered by time
 * @returns { highTime, lowTime, highBeforeLow, reversalType } or null if bars is empty
 */
export function computeIntradayTimingFields(
  bars: Array<{ time: string; high: number; low: number }>
): {
  highTime: number;     // Decimal hours (e.g., 10.5 = 10:30)
  lowTime: number;      // Decimal hours
  highBeforeLow: boolean; // true if high occurred before low
  reversalType: number;   // +1 = morning high + afternoon low, -1 = morning low + afternoon high, 0 = trend day
} | null {
  if (bars.length === 0) return null;

  let maxHigh = -Infinity;
  let minLow = Infinity;
  let highTimeStr = bars[0].time;
  let lowTimeStr = bars[0].time;

  for (const bar of bars) {
    if (bar.high > maxHigh) {
      maxHigh = bar.high;
      highTimeStr = bar.time;
    }
    if (bar.low < minLow) {
      minLow = bar.low;
      lowTimeStr = bar.time;
    }
  }

  const highTime = hhmmToDecimalHours(highTimeStr);
  const lowTime = hhmmToDecimalHours(lowTimeStr);
  const highBeforeLow = highTime < lowTime;

  // Reversal type: morning = before 12:00, afternoon = 12:00 or later
  const highInMorning = highTime < 12;
  const lowInMorning = lowTime < 12;
  const highInAfternoon = highTime >= 12;
  const lowInAfternoon = lowTime >= 12;

  let reversalType = 0;
  if (highInMorning && lowInAfternoon) reversalType = 1;    // High morning, low afternoon
  else if (lowInMorning && highInAfternoon) reversalType = -1; // Low morning, high afternoon

  return { highTime, lowTime, highBeforeLow, reversalType };
}

function hhmmToDecimalHours(time: string): number {
  const [h, m] = time.split(':').map(Number);
  return h + m / 60;
}
```

2. **Add `runTier3` function** following the same pattern as `runTier2`:
```typescript
async function runTier3(
  conn: DuckDBConnection,
  ticker: string,
  dates: string[]
): Promise<TierStatus> {
  // Check if intraday data exists for this ticker
  const hasData = await hasTier3Data(conn, ticker);
  if (!hasData) {
    return {
      status: "skipped",
      reason: "no intraday data in market.intraday — import intraday bars to populate High_Time, Low_Time, Reversal_Type",
    };
  }

  // Query intraday bars for all dates in the enrichment range
  const result = await conn.runAndReadAll(
    `SELECT date, time, high, low
     FROM market.intraday
     WHERE ticker = $1 AND date >= $2 AND date <= $3
     ORDER BY date, time`,
    [ticker, dates[0], dates[dates.length - 1]]
  );

  const rows = result.getRows();
  const columns = result.columnNames();
  const dateIdx = columns.indexOf("date");
  const timeIdx = columns.indexOf("time");
  const highIdx = columns.indexOf("high");
  const lowIdx = columns.indexOf("low");

  // Group bars by date
  const barsByDate = new Map<string, Array<{ time: string; high: number; low: number }>>();
  for (const row of rows) {
    const dateStr = String(row[dateIdx]);
    const bar = {
      time: String(row[timeIdx]),
      high: Number(row[highIdx]),
      low: Number(row[lowIdx]),
    };
    if (!barsByDate.has(dateStr)) barsByDate.set(dateStr, []);
    barsByDate.get(dateStr)!.push(bar);
  }

  if (barsByDate.size === 0) {
    return {
      status: "skipped",
      reason: "intraday data exists but no bars overlap with enrichment date range",
    };
  }

  // Compute timing fields for each date and batch update market.daily
  const tier3Cols = ["High_Time", "Low_Time", "High_Before_Low", "Reversal_Type"];
  const enrichedRows: Array<{ date: string; values: Record<string, unknown> }> = [];

  for (const [dateStr, bars] of barsByDate) {
    const timing = computeIntradayTimingFields(bars);
    if (!timing) continue;

    enrichedRows.push({
      date: dateStr,
      values: {
        High_Time: timing.highTime,
        Low_Time: timing.lowTime,
        High_Before_Low: timing.highBeforeLow ? 1 : 0, // Store as integer (0/1) per schema
        Reversal_Type: timing.reversalType,
      },
    });
  }

  // Batch update using the existing batchUpdateDaily helper
  // batchUpdateDaily expects rows as Record<string, unknown>[] with date + columns
  const BATCH_SIZE = 500;
  const updateRows = enrichedRows.map(r => ({ date: r.date, ticker, ...r.values }));
  for (let start = 0; start < updateRows.length; start += BATCH_SIZE) {
    const batch = updateRows.slice(start, start + BATCH_SIZE);
    await batchUpdateDaily(conn, batch, tier3Cols);
  }

  return { status: "complete", fieldsWritten: tier3Cols.length };
}
```

Note: Check how `batchUpdateDaily` accepts rows. It may need the rows to have `date` and the column values directly on the object. Match the existing pattern from Tier 1 enrichment (look at how `enrichedRows` is structured before being passed to `batchUpdateDaily` — around line 888). If `batchUpdateDaily` expects `{date: string, [column]: value}` format, structure `updateRows` accordingly.

3. **Replace the hard-skip at lines 897-909** with actual `runTier3` call:
```typescript
  // 10. Tier 3 — intraday timing fields from market.intraday
  const tier3Result = await runTier3(conn, ticker, dates);
```

Remove the old `hasTier3` variable and the old `tier3Result` ternary (lines 898-909). The `hasTier3Data` function at line 667 stays — it's called inside `runTier3` now.

4. **Update the enricher JSDoc** (lines 690-692): Remove the "Schema gaps" comment about `Opening_Drive_Strength` and `Intraday_Realized_Vol` as Tier 3 gaps. Instead, note that Tier 3 writes 4 fields: `High_Time`, `Low_Time`, `High_Before_Low`, `Reversal_Type`. Keep the note about `Opening_Drive_Strength` and `Intraday_Realized_Vol` as future additions requiring schema migration.

5. **Export `computeIntradayTimingFields`** from the module (add `export` keyword to the function declaration). The `test-exports.ts` entry is handled by Plan 64-01 Task 1 — do NOT modify `test-exports.ts` in this plan.
  </action>
  <verify>
1. `cd packages/mcp-server && npx tsc --noEmit` — no TypeScript errors
2. `cd packages/mcp-server && npm run build` — build succeeds
3. `grep -n "runTier3" packages/mcp-server/src/utils/market-enricher.ts` — function exists
4. `grep -n "computeIntradayTimingFields" packages/mcp-server/src/utils/market-enricher.ts` — exported function exists
5. Verify the hard-skip at line 897 is replaced with `runTier3` call
  </verify>
  <done>Tier 3 enrichment reads bars from market.intraday, computes High_Time/Low_Time/High_Before_Low/Reversal_Type via pure computeIntradayTimingFields function, and batch-updates market.daily; gracefully skips when no intraday data exists</done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for Tier 3 computation logic</name>
  <files>
    packages/mcp-server/tests/unit/tier3-enrichment.test.ts
  </files>
  <action>
**Note:** The `computeIntradayTimingFields` export in `test-exports.ts` is handled by Plan 64-01 Task 1 (which consolidates all test-exports.ts edits). This task only creates the test file — the export will already exist when this task runs.

1. **Create** `packages/mcp-server/tests/unit/tier3-enrichment.test.ts` with the following test cases:

```typescript
import { computeIntradayTimingFields } from "../../dist/test-exports.js";

describe("computeIntradayTimingFields", () => {
  it("returns null for empty bars array", () => {
    expect(computeIntradayTimingFields([])).toBeNull();
  });

  it("computes High_Time and Low_Time in decimal hours", () => {
    const bars = [
      { time: "09:30", high: 100, low: 99 },
      { time: "10:00", high: 102, low: 98 },   // Highest high
      { time: "14:30", high: 101, low: 97 },   // Lowest low
      { time: "15:45", high: 100.5, low: 99 },
    ];
    const result = computeIntradayTimingFields(bars)!;
    expect(result.highTime).toBe(10);        // 10:00 = 10.0 decimal hours
    expect(result.lowTime).toBe(14.5);       // 14:30 = 14.5 decimal hours
  });

  it("detects highBeforeLow when high occurs earlier", () => {
    const bars = [
      { time: "09:30", high: 105, low: 100 }, // High of day
      { time: "15:00", high: 101, low: 96 },  // Low of day
    ];
    const result = computeIntradayTimingFields(bars)!;
    expect(result.highBeforeLow).toBe(true);
  });

  it("detects highBeforeLow=false when low occurs earlier", () => {
    const bars = [
      { time: "09:30", high: 100, low: 95 },  // Low of day
      { time: "15:00", high: 106, low: 100 }, // High of day
    ];
    const result = computeIntradayTimingFields(bars)!;
    expect(result.highBeforeLow).toBe(false);
  });

  it("reversalType = +1 when high in morning, low in afternoon", () => {
    const bars = [
      { time: "10:00", high: 110, low: 105 }, // Morning high of day
      { time: "14:00", high: 104, low: 98 },  // Afternoon low of day
    ];
    const result = computeIntradayTimingFields(bars)!;
    expect(result.reversalType).toBe(1);
  });

  it("reversalType = -1 when low in morning, high in afternoon", () => {
    const bars = [
      { time: "10:00", high: 100, low: 95 },  // Morning low of day
      { time: "14:00", high: 108, low: 100 }, // Afternoon high of day
    ];
    const result = computeIntradayTimingFields(bars)!;
    expect(result.reversalType).toBe(-1);
  });

  it("reversalType = 0 for trend day (both extremes in morning)", () => {
    const bars = [
      { time: "09:30", high: 100, low: 95 },  // Low of day (morning)
      { time: "11:00", high: 108, low: 100 }, // High of day (morning)
      { time: "14:00", high: 106, low: 99 },
    ];
    const result = computeIntradayTimingFields(bars)!;
    expect(result.reversalType).toBe(0);
  });

  it("reversalType = 0 for trend day (both extremes in afternoon)", () => {
    const bars = [
      { time: "09:30", high: 102, low: 100 },
      { time: "13:00", high: 105, low: 97 },  // Low of day (afternoon)
      { time: "15:00", high: 110, low: 100 }, // High of day (afternoon)
    ];
    const result = computeIntradayTimingFields(bars)!;
    expect(result.reversalType).toBe(0);
  });

  it("handles single bar (edge case)", () => {
    const bars = [{ time: "12:00", high: 100, low: 95 }];
    const result = computeIntradayTimingFields(bars)!;
    expect(result.highTime).toBe(12);
    expect(result.lowTime).toBe(12);
    expect(result.highBeforeLow).toBe(false); // Same time, not "before"
    expect(result.reversalType).toBe(0);       // Same bar, no reversal
  });

  it("uses first occurrence when multiple bars share the same extreme", () => {
    const bars = [
      { time: "10:00", high: 105, low: 100 },
      { time: "14:00", high: 105, low: 100 }, // Same high and low
    ];
    const result = computeIntradayTimingFields(bars)!;
    // First occurrence wins (strict > / < comparison)
    expect(result.highTime).toBe(10);
    expect(result.lowTime).toBe(10);
  });
});
```

3. Run the build first (`cd packages/mcp-server && npm run build`), then run the tests (`npm test -- tests/unit/tier3-enrichment.test.ts`).
  </action>
  <verify>
1. `cd packages/mcp-server && npm run build` — build succeeds (needed for dist/test-exports.js)
2. `npm test -- tests/unit/tier3-enrichment.test.ts` — all tests pass
3. `grep -n "computeIntradayTimingFields" packages/mcp-server/src/test-exports.ts` — export exists (added by Plan 64-01)
  </verify>
  <done>Unit tests for computeIntradayTimingFields cover: empty input, decimal hour conversion, highBeforeLow detection, all three reversalType values (+1, -1, 0), single bar edge case, and tied extremes; all tests pass</done>
</task>

</tasks>

<verification>
1. `cd packages/mcp-server && npm run build` — clean build
2. `npm test -- tests/unit/tier3-enrichment.test.ts` — all Tier 3 tests pass
3. `grep -n "always skipped" packages/mcp-server/src/utils/market-enricher.ts` — returns no results (hard-skip removed)
4. `grep -n "runTier3" packages/mcp-server/src/utils/market-enricher.ts` — function exists and is called
</verification>

<success_criteria>
- Tier 3 enrichment computes High_Time, Low_Time, High_Before_Low, Reversal_Type from market.intraday
- Tier 3 gracefully skips when no intraday data exists (status: "skipped")
- computeIntradayTimingFields has comprehensive unit tests (8+ test cases)
- Opening_Drive_Strength and Intraday_Realized_Vol are NOT implemented (schema gaps, out of scope)
- Build succeeds and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/64-cleanup-and-api-surface/64-03-SUMMARY.md`
</output>
