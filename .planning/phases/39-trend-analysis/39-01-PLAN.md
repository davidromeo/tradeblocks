---
phase: 39-trend-analysis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mcp-server/src/tools/reports.ts
  - packages/mcp-server/package.json
autonomous: true

must_haves:
  truths:
    - "Model can get time-series slippage data aggregated by period (daily/weekly/monthly)"
    - "Model can detect trend direction with statistical significance (p-value, R-squared)"
    - "Model can see if slippage is improving (negative slope) or degrading (positive slope)"
    - "Model can correlate slippage trends with external factors when data is available"
    - "Model receives both block-level summary and per-strategy breakdown"
  artifacts:
    - path: "packages/mcp-server/src/tools/reports.ts"
      provides: "analyze_slippage_trends MCP tool"
      contains: "analyze_slippage_trends"
    - path: "packages/mcp-server/package.json"
      provides: "Version bump"
      contains: "0.4.8"
  key_links:
    - from: "analyze_slippage_trends"
      to: "trade matching logic"
      via: "Same pattern as analyze_discrepancies"
      pattern: "matchedTrades.*totalSlippage"
    - from: "analyze_slippage_trends"
      to: "linearRegression"
      via: "Inline implementation using mathjs mean"
      pattern: "slope.*intercept.*rSquared.*pValue"
    - from: "analyze_slippage_trends"
      to: "time period aggregation"
      via: "getIsoWeekKey, getMonthKey helpers"
      pattern: "granularity.*daily.*weekly.*monthly"
---

<objective>
Implement the `analyze_slippage_trends` MCP tool that analyzes slippage trends over time and detects improvement/degradation patterns.

Purpose: Enable AI models to identify whether slippage is getting better or worse over time, with statistical confidence levels, supporting data-driven improvement of trading execution.

Output: New MCP tool registered in reports.ts with linear regression-based trend detection, time-series aggregation, and optional external factor correlation.
</objective>

<execution_context>
@/Users/davidromeo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidromeo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase context
@.planning/phases/39-trend-analysis/39-CONTEXT.md
@.planning/phases/39-trend-analysis/39-RESEARCH.md

# Prior phase summary (trade matching pattern)
@.planning/phases/37-discrepancy-analysis/37-01-SUMMARY.md

# Key source files
@packages/mcp-server/src/tools/reports.ts
@packages/lib/calculations/statistical-utils.ts
@packages/lib/calculations/correlation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement analyze_slippage_trends MCP tool</name>
  <files>packages/mcp-server/src/tools/reports.ts</files>
  <action>
Add the `analyze_slippage_trends` MCP tool to `registerReportTools()` function. Follow the exact pattern from `analyze_discrepancies` for trade matching.

**Input Schema (Zod):**
```typescript
z.object({
  blockId: z.string().describe("Block folder name"),
  strategy: z.string().optional().describe("Filter to specific strategy name"),
  dateRange: z.object({
    from: z.string().optional().describe("Start date YYYY-MM-DD"),
    to: z.string().optional().describe("End date YYYY-MM-DD"),
  }).optional().describe("Filter trades to date range"),
  scaling: z.enum(["raw", "perContract", "toReported"]).default("toReported")
    .describe("Scaling mode for P/L comparison"),
  granularity: z.enum(["daily", "weekly", "monthly"]).default("weekly")
    .describe("Time period granularity for trend analysis"),
  includeTimeSeries: z.boolean().default(false)
    .describe("Include raw time series data points in output (for charting)"),
  correlationMethod: z.enum(["pearson", "kendall"]).default("pearson")
    .describe("Correlation method for external factor analysis"),
  minSamples: z.number().min(5).default(10)
    .describe("Minimum samples required for reliable statistics"),
})
```

**Core Implementation Steps:**

1. **Trade Matching** - Reuse the exact pattern from `analyze_discrepancies`:
   - Load block and reporting log
   - Apply strategy/date filters
   - Build lookup map for actual trades by date+strategy+time
   - Match trades and calculate totalSlippage per matched trade
   - Collect MatchedTradeData array with: date, strategy, timeOpened, totalSlippage, openingVix, hourOfDay, contracts

2. **Time Period Aggregation** - Group matched trades by period:
   ```typescript
   interface PeriodSlippage {
     period: string;           // YYYY-MM-DD, YYYY-Www, or YYYY-MM
     totalSlippage: number;    // Sum of slippage in period
     avgSlippage: number;      // Mean slippage per trade
     tradeCount: number;       // Number of matched trades
     avgMagnitude: number;     // Mean |slippage|
   }
   ```
   Use existing `getIsoWeekKey()` and `getMonthKey()` helper patterns from the file (or inline if needed).

3. **Linear Regression with Statistics** - Implement inline:
   ```typescript
   interface TrendResult {
     slope: number;           // Slippage change per period
     intercept: number;
     rSquared: number;        // Coefficient of determination
     pValue: number;          // Two-tailed p-value for slope
     stderr: number;          // Standard error of slope
     interpretation: 'improving' | 'stable' | 'degrading';
     confidence: 'high' | 'moderate' | 'low';  // Based on sample size
   }

   function linearRegression(x: number[], y: number[]): TrendResult {
     const n = x.length;
     if (n < 2) return null; // Not enough data

     // Calculate means
     const meanX = x.reduce((a,b) => a+b, 0) / n;
     const meanY = y.reduce((a,b) => a+b, 0) / n;

     // OLS: slope = sum((xi-meanX)(yi-meanY)) / sum((xi-meanX)^2)
     let sumXY = 0, sumX2 = 0;
     for (let i = 0; i < n; i++) {
       sumXY += (x[i] - meanX) * (y[i] - meanY);
       sumX2 += (x[i] - meanX) ** 2;
     }
     const slope = sumX2 > 0 ? sumXY / sumX2 : 0;
     const intercept = meanY - slope * meanX;

     // R-squared = 1 - SSres/SStot
     const predicted = x.map(xi => slope * xi + intercept);
     const ssRes = y.reduce((sum, yi, i) => sum + (yi - predicted[i]) ** 2, 0);
     const ssTot = y.reduce((sum, yi) => sum + (yi - meanY) ** 2, 0);
     const rSquared = ssTot > 0 ? 1 - (ssRes / ssTot) : 0;

     // Standard error and t-statistic for p-value
     const mse = n > 2 ? ssRes / (n - 2) : 0;
     const stderr = sumX2 > 0 ? Math.sqrt(mse / sumX2) : 0;
     const tStat = stderr > 0 ? slope / stderr : 0;

     // Two-tailed p-value using normal approximation (import normalCDF from lib)
     const pValue = 2 * (1 - normalCDF(Math.abs(tStat)));

     // Interpretation
     const isSignificant = pValue < 0.05;
     let interpretation: 'improving' | 'stable' | 'degrading';
     if (!isSignificant) {
       interpretation = 'stable';
     } else if (slope < 0) {
       interpretation = 'improving';  // Slippage decreasing over time
     } else {
       interpretation = 'degrading';  // Slippage increasing over time
     }

     return {
       slope, intercept, rSquared, pValue, stderr,
       interpretation,
       confidence: n >= 30 ? 'high' : n >= 10 ? 'moderate' : 'low'
     };
   }
   ```

4. **Per-Strategy Analysis** - For each strategy with sufficient data:
   - Aggregate slippage by period
   - Run linear regression
   - Include strategy-level trend results

5. **External Factor Correlation** (skip if insufficient data):
   - Only if trades have openingVix populated
   - Require minSamples for correlation
   - Use pearsonCorrelation or kendallTau from @tradeblocks/lib
   - Report correlation coefficient and interpretation label
   - OMIT section entirely if insufficient data (don't return nulls)

**Output Structure:**
```typescript
{
  blockId: string,
  filters: { strategy, dateRange },
  scaling: string,
  granularity: string,
  dateRange: { from: string, to: string },

  summary: {
    matchedTrades: number,
    periodsAnalyzed: number,
    totalSlippage: number,
    avgSlippagePerTrade: number,
    avgSlippagePerPeriod: number,
  },

  trend: TrendResult,  // Block-level trend

  // Only if includeTimeSeries: true
  timeSeries?: PeriodSlippage[],

  // Per-strategy breakdown (only strategies with >= minSamples trades)
  perStrategy: Array<{
    strategy: string,
    matchedTrades: number,
    periodsAnalyzed: number,
    totalSlippage: number,
    trend: TrendResult | null,  // null if insufficient periods
  }>,

  // Only if VIX data available and >= minSamples
  externalFactors?: {
    method: string,
    results: Array<{
      factor: string,
      coefficient: number,
      interpretation: string,  // 'strong positive', 'moderate negative', etc.
      sampleSize: number,
    }>
  },
}
```

**Import Required:**
- Add `normalCDF` to the existing imports from `@tradeblocks/lib` (it's exported from statistical-utils.ts)

**Helper Functions to Inline:**
- `getIsoWeekKey(dateStr: string): string` - Return YYYY-Www format
- `getMonthKey(dateStr: string): string` - Return YYYY-MM format
- `getCorrelationInterpretation(r: number): string` - Return human-readable label

**Error Handling:**
- Return error if no reportinglog.csv found
- Return error if no matched trades
- Return warning in summary if periods < minSamples
  </action>
  <verify>
Run lint and build:
```bash
cd /Users/davidromeo/Code/tradeblocks && npm run lint && npm run build
```
Both should pass without errors.
  </verify>
  <done>
The `analyze_slippage_trends` MCP tool is registered with:
- Trade matching using same pattern as analyze_discrepancies
- Time period aggregation (daily/weekly/monthly)
- Linear regression with slope, intercept, R-squared, p-value
- Trend interpretation (improving/stable/degrading)
- Per-strategy breakdown
- Optional external factor correlation
- Optional raw time series output
  </done>
</task>

<task type="auto">
  <name>Task 2: CLI verification and version bump</name>
  <files>packages/mcp-server/package.json</files>
  <action>
1. **Bump MCP server version** from 0.4.7 to 0.4.8 in `packages/mcp-server/package.json`

2. **Rebuild and test via CLI:**
```bash
cd /Users/davidromeo/Code/tradeblocks/packages/mcp-server && npm run build

# Test the new tool with a real block
TRADEBLOCKS_DATA_DIR=~/backtests tradeblocks-mcp --call analyze_slippage_trends '{"blockId":"main-port-2026-ytd","granularity":"weekly"}'
```

3. **Verify output contains:**
   - `summary` with matchedTrades, periodsAnalyzed, totalSlippage
   - `trend` with slope, rSquared, pValue, interpretation
   - `perStrategy` array with per-strategy trends
   - No errors in output

4. **Test with includeTimeSeries:**
```bash
TRADEBLOCKS_DATA_DIR=~/backtests tradeblocks-mcp --call analyze_slippage_trends '{"blockId":"main-port-2026-ytd","granularity":"weekly","includeTimeSeries":true}'
```
Verify `timeSeries` array is present in output.
  </action>
  <verify>
All CLI test commands execute successfully and return valid JSON with expected structure.
  </verify>
  <done>
MCP server version is 0.4.8. CLI tests confirm:
- Tool returns trend analysis with statistical measures
- Per-strategy breakdown is included
- Time series data is optionally returned
- No runtime errors
  </done>
</task>

</tasks>

<verification>
1. `npm run lint` passes
2. `npm run build` passes
3. CLI test of `analyze_slippage_trends` returns valid JSON with:
   - Block-level trend (slope, pValue, rSquared, interpretation)
   - Per-strategy breakdown
   - Optional time series data
4. MCP server version is 0.4.8
</verification>

<success_criteria>
- [ ] `analyze_slippage_trends` MCP tool is registered and callable
- [ ] Tool returns time-series slippage aggregated by granularity (daily/weekly/monthly)
- [ ] Tool calculates linear regression with slope, R-squared, p-value
- [ ] Tool interprets trend as improving/stable/degrading based on statistical significance
- [ ] Tool provides per-strategy breakdown with individual trends
- [ ] Tool correlates with external factors when data is available (VIX)
- [ ] MCP server version bumped to 0.4.8
- [ ] All verification commands pass
</success_criteria>

<output>
After completion, create `.planning/phases/39-trend-analysis/39-01-SUMMARY.md` using the summary template.
</output>
