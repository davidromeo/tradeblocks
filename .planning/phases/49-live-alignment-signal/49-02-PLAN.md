---
phase: 49-live-alignment-signal
plan: 02
type: execute
wave: 2
depends_on: ["49-01"]
files_modified:
  - packages/mcp-server/src/tools/edge-decay.ts
  - packages/mcp-server/package.json
autonomous: true

must_haves:
  truths:
    - "MCP tool analyze_live_alignment returns alignment metrics when reporting log exists"
    - "MCP tool analyze_live_alignment returns graceful skip when no reporting log exists"
    - "MCP tool accepts blockId, optional strategy filter, and optional scaling mode"
    - "Tool output includes both human-readable text summary and structured JSON data"
    - "Local filterByStrategy in edge-decay.ts replaced with applyStrategyFilter import from @tradeblocks/lib"
  artifacts:
    - path: "packages/mcp-server/src/tools/edge-decay.ts"
      provides: "Fifth edge decay MCP tool: analyze_live_alignment, using shared applyStrategyFilter from lib"
      contains: "analyze_live_alignment"
    - path: "packages/mcp-server/package.json"
      provides: "Version bump for new tool"
  key_links:
    - from: "packages/mcp-server/src/tools/edge-decay.ts"
      to: "packages/lib/calculations/live-alignment.ts"
      via: "import analyzeLiveAlignment from @tradeblocks/lib"
      pattern: "analyzeLiveAlignment"
    - from: "packages/mcp-server/src/tools/edge-decay.ts"
      to: "packages/lib/calculations/trade-matching.ts"
      via: "import applyStrategyFilter from @tradeblocks/lib"
      pattern: "applyStrategyFilter"
    - from: "packages/mcp-server/src/tools/edge-decay.ts"
      to: "packages/mcp-server/src/utils/block-loader.ts"
      via: "import loadReportingLog"
      pattern: "loadReportingLog"
---

<objective>
Register `analyze_live_alignment` as the fifth edge decay MCP tool, wiring the lib calculation engine to block/reporting log loading with graceful skip when no reporting log exists. Also consolidate the local `filterByStrategy` duplicate by replacing it with `applyStrategyFilter` from `@tradeblocks/lib`.

Purpose: Makes live alignment signals accessible to Claude and MCP clients, completing the four signal categories needed by Phase 50's verdict synthesis. Eliminates the duplicated strategy filter function.
Output: Fifth tool in edge-decay.ts, callable via CLI `--call analyze_live_alignment`.
</objective>

<execution_context>
@/Users/davidromeo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidromeo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-live-alignment-signal/49-01-SUMMARY.md

# Source patterns
@packages/mcp-server/src/tools/edge-decay.ts
@packages/mcp-server/src/utils/block-loader.ts
@packages/mcp-server/src/utils/output-formatter.ts
@packages/mcp-server/src/tools/middleware/sync-middleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register analyze_live_alignment MCP tool and consolidate filterByStrategy</name>
  <files>
    packages/mcp-server/src/tools/edge-decay.ts
    packages/mcp-server/package.json
  </files>
  <action>
Add the fifth edge decay tool to `packages/mcp-server/src/tools/edge-decay.ts` following the exact pattern of Tools 1-4. Also replace the local `filterByStrategy` duplicate with the shared `applyStrategyFilter` from `@tradeblocks/lib`.

**Changes to edge-decay.ts:**

1. **Update module JSDoc** at top of file: Add "live alignment" to the list of tools in the comment.

2. **Update imports from `@tradeblocks/lib`:**
   - Add `analyzeLiveAlignment` and `applyStrategyFilter` to the existing import
   - Add `type { ReportingTrade }` to the type import
   ```typescript
   import {
     segmentByPeriod,
     computeRollingMetrics,
     runRegimeComparison,
     analyzeWalkForwardDegradation,
     analyzeLiveAlignment,
     applyStrategyFilter,
   } from "@tradeblocks/lib";
   import type { Trade, ReportingTrade } from "@tradeblocks/lib";
   ```

3. **Add block-loader import for reporting log:**
   ```typescript
   import { loadBlock, loadReportingLog } from "../utils/block-loader.js";
   ```
   (Update the existing `loadBlock` import to also include `loadReportingLog`)

4. **Remove the local `filterByStrategy` function** (lines 22-30) and replace all calls to `filterByStrategy(trades, strategy)` with `applyStrategyFilter(trades, strategy)` throughout the file. The function signatures are identical — both accept `<T extends { strategy: string }>(trades: T[], strategy?: string): T[]` and do case-insensitive comparison. This is a find-and-replace within this file only.

5. **Register Tool 5** after the WFD tool registration:
   ```typescript
   // Tool 5: analyze_live_alignment
   server.registerTool(
     "analyze_live_alignment",
     {
       description: "Compare backtest trades against actual (reporting log) trades to assess live execution alignment. Computes direction agreement rate (% of days where both agree on win/loss), per-strategy execution efficiency (actual P/L as ratio of backtest P/L), and alignment trend over time via monthly regression. Returns graceful skip when no reporting log exists.",
       inputSchema: z.object({
         blockId: z.string().describe("Block folder name"),
         strategy: z.string().optional().describe("Filter by strategy name (case-insensitive)"),
         scaling: z.enum(["raw", "perContract", "toReported"]).optional()
           .describe("P/L scaling mode: raw (as-is), perContract (divide by contracts, default), toReported (scale backtest to actual contract count)"),
       }),
     },
     withSyncedBlock(baseDir, async ({ blockId, strategy, scaling }) => {
       try {
         const block = await loadBlock(baseDir, blockId);

         // Load reporting log -- graceful skip if missing (LIVE-04)
         let actualTrades: ReportingTrade[];
         try {
           actualTrades = await loadReportingLog(baseDir, blockId);
         } catch {
           return createToolOutput(
             `Live alignment for ${blockId}: skipped (no reporting log found)`,
             {
               blockId,
               strategy: strategy ?? null,
               available: false,
               reason: "no reporting log",
             }
           );
         }

         // Apply strategy filter to both sets
         let backtestTrades = applyStrategyFilter(block.trades, strategy);
         actualTrades = applyStrategyFilter(actualTrades, strategy);

         if (backtestTrades.length === 0) {
           return {
             content: [{
               type: "text" as const,
               text: strategy
                 ? `No backtest trades found for strategy "${strategy}" in block "${blockId}".`
                 : `No backtest trades found in block "${blockId}".`,
             }],
             isError: true as const,
           };
         }

         // Call pure calculation engine
         const result = analyzeLiveAlignment(backtestTrades, actualTrades, {
           scaling: scaling ?? "perContract",
         });

         // Build text summary
         const da = result.directionAgreement;
         const ee = result.executionEfficiency;
         const dq = result.dataQuality;
         const fmtPct = (v: number) => (v * 100).toFixed(1) + "%";
         const fmtVal = (v: number | null) => v !== null ? v.toFixed(2) : "N/A";

         const summary = [
           `Live alignment for ${blockId}${strategy ? ` (${strategy})` : ""}: ${dq.backtestTradeCount} backtest, ${dq.actualTradeCount} actual, ${dq.matchedTradeCount} matched (${fmtPct(dq.matchRate)})`,
           `Direction agreement: ${fmtPct(da.overallRate)} (${da.agreementDays}/${da.totalDays} days)`,
           `Execution efficiency: ${fmtVal(ee.overallEfficiency)}`,
           `Trend sufficient: ${result.alignmentTrend.sufficientForTrends ? "yes" : "no"}, Direction trend slope: ${result.alignmentTrend.directionTrend?.slope !== undefined ? result.alignmentTrend.directionTrend.slope.toFixed(4) : "N/A"}`,
         ].join("\n");

         const structuredData = {
           blockId,
           strategy: strategy ?? null,
           available: true,
           overlapDateRange: result.overlapDateRange,
           directionAgreement: result.directionAgreement,
           executionEfficiency: result.executionEfficiency,
           alignmentTrend: result.alignmentTrend,
           dataQuality: result.dataQuality,
         };

         return createToolOutput(summary, structuredData);
       } catch (error) {
         return {
           content: [{
             type: "text" as const,
             text: `Error analyzing live alignment: ${(error as Error).message}`,
           }],
           isError: true as const,
         };
       }
     })
   );
   ```

6. **Version bump:** In `packages/mcp-server/package.json`, bump version from `0.7.2` to `0.7.3`.

**Key constraints:**
- Graceful skip returns `createToolOutput` (NOT error), per CONTEXT.md locked decision
- Strategy filter applied to BOTH backtest and actual trades before calling engine
- Text summary uses same formatting conventions as other edge decay tools (2 decimal places for ratios, 4 for slopes)
- Structured data mirrors the `LiveAlignmentResult` shape with `blockId` and `strategy` prepended
- All `filterByStrategy` calls in tools 1-4 replaced with `applyStrategyFilter` — one source of truth
  </action>
  <verify>
1. `cd /Users/davidromeo/Code/tradeblocks/packages/mcp-server && npm run build` -- builds without errors
2. `npm test` -- all existing tests still pass (no regressions from filterByStrategy rename)
3. `TRADEBLOCKS_DATA_DIR=~/backtests tradeblocks-mcp --call analyze_live_alignment '{"blockId":"main-port-2026"}'` -- returns either alignment metrics or graceful skip (depending on whether reporting log exists)
  </verify>
  <done>
`analyze_live_alignment` is registered as the fifth edge decay MCP tool. Local `filterByStrategy` removed in favor of `applyStrategyFilter` from `@tradeblocks/lib`. When reporting log exists, returns direction agreement, execution efficiency, and alignment trends. When no reporting log exists, returns `{ available: false, reason: "no reporting log" }` via createToolOutput (not error). MCP server builds cleanly and all existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. MCP server compiles: `cd packages/mcp-server && npm run build` succeeds
2. Full test suite: `npm test` passes with 0 regressions
3. CLI test with block that HAS reporting log returns alignment metrics
4. CLI test with block that has NO reporting log returns graceful skip (available: false)
5. Strategy filter works: `--call analyze_live_alignment '{"blockId":"main-port-2026","strategy":"Iron Condor"}'`
6. No local `filterByStrategy` function remains in edge-decay.ts (replaced by `applyStrategyFilter` import)
</verification>

<success_criteria>
- `analyze_live_alignment` tool registered and callable via MCP
- Graceful skip when no reporting log (returns non-error response with `available: false`)
- Text summary + structured JSON output matching other edge decay tools
- MCP server version bumped to 0.7.3
- Local `filterByStrategy` eliminated — all tools use `applyStrategyFilter` from lib
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/49-live-alignment-signal/49-02-SUMMARY.md`
</output>
