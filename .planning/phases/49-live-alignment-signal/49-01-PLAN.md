---
phase: 49-live-alignment-signal
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/lib/calculations/live-alignment.ts
  - packages/lib/calculations/index.ts
  - tests/unit/live-alignment.test.ts
autonomous: true

must_haves:
  truths:
    - "Given backtest and actual trades, direction agreement rate is calculated per strategy and overall"
    - "Given backtest and actual trades, per-contract execution efficiency is calculated per strategy"
    - "Given matched trades over multiple months, alignment trend regression detects improving or degrading execution"
    - "Given insufficient monthly data points (<4), trends return null with sufficientForTrends=false"
    - "Data quality metrics report match rate, overlap date range, and unmatched trade counts"
  artifacts:
    - path: "packages/lib/calculations/live-alignment.ts"
      provides: "Pure function calculation engine for live alignment signals"
      exports: ["analyzeLiveAlignment", "LiveAlignmentResult", "LiveAlignmentSkipped", "LiveAlignmentOutput", "LiveAlignmentOptions"]
    - path: "packages/lib/calculations/index.ts"
      provides: "Barrel export including live-alignment"
      contains: "live-alignment"
    - path: "tests/unit/live-alignment.test.ts"
      provides: "Unit tests for all live alignment calculations"
      min_lines: 100
  key_links:
    - from: "packages/lib/calculations/live-alignment.ts"
      to: "packages/lib/calculations/trend-detection.ts"
      via: "import computeTrends"
      pattern: "import.*computeTrends.*from.*trend-detection"
    - from: "packages/lib/calculations/live-alignment.ts"
      to: "packages/lib/models/trade.ts"
      via: "import Trade type"
      pattern: "import.*Trade.*from.*models/trade"
    - from: "packages/lib/calculations/live-alignment.ts"
      to: "packages/lib/models/reporting-trade.ts"
      via: "import ReportingTrade type"
      pattern: "import.*ReportingTrade.*from.*models/reporting-trade"
---

<objective>
Create the live alignment calculation engine that derives direction agreement, execution efficiency, and alignment trend signals from backtest vs actual trade comparison.

Purpose: Provides the fourth signal category (live alignment) for Phase 50's unified edge decay verdict. When reporting log data exists, this engine quantifies how well live execution matches backtest expectations.
Output: Pure function engine in packages/lib/calculations/live-alignment.ts with comprehensive tests.
</objective>

<execution_context>
@/Users/davidromeo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidromeo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-live-alignment-signal/49-RESEARCH.md

# Source patterns and types
@packages/lib/calculations/walk-forward-degradation.ts
@packages/lib/calculations/trend-detection.ts
@packages/lib/calculations/index.ts
@packages/lib/models/trade.ts
@packages/lib/models/reporting-trade.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement live alignment calculation engine</name>
  <files>
    packages/lib/calculations/live-alignment.ts
    packages/lib/calculations/index.ts
  </files>
  <action>
Create `packages/lib/calculations/live-alignment.ts` as a pure function calculation engine (~200-250 lines) following the exact pattern from `walk-forward-degradation.ts`. The engine must:

**Main export:**
```typescript
export function analyzeLiveAlignment(
  backtestTrades: Trade[],
  actualTrades: ReportingTrade[],
  options?: LiveAlignmentOptions
): LiveAlignmentResult
```

**Types to export:**
- `LiveAlignmentOptions` with optional `scaling: 'raw' | 'perContract' | 'toReported'` (default: `perContract`)
- `LiveAlignmentResult` with `available: true`, `overlapDateRange`, `directionAgreement`, `executionEfficiency`, `alignmentTrend`, `dataQuality`
- `LiveAlignmentSkipped` with `available: false, reason: string`
- `LiveAlignmentOutput = LiveAlignmentResult | LiveAlignmentSkipped`
- `DirectionAgreementResult` with `overallRate`, `totalDays`, `agreementDays`, `byStrategy` array
- `ExecutionEfficiencyResult` with `overallEfficiency`, `totalActualPl`, `totalBacktestPl`, `byStrategy` array (each with `efficiency`, `perContractGap`, `actualPerContract`, `backtestPerContract`, `matchedTrades`, `unmatchedBacktest`, `unmatchedActual`, `underperforming`, `slippageStdDev`)
- `AlignmentTrendResult` with `monthlySeries` array, `directionTrend: TrendResult | null`, `efficiencyTrend: TrendResult | null`, `sufficientForTrends: boolean`
- `AlignmentDataQuality` with `backtestTradeCount`, `actualTradeCount`, `matchedTradeCount`, `matchRate`, `overlapMonths`, `backtestDateRange`, `actualDateRange`, `overlapDateRange`, `sufficientForTrends`, `warnings` array

**Implementation details:**

1. **Trade matching (inline, ~40 lines):** Match by date+strategy+time key at minute precision. Build a key for each trade: `YYYY-MM-DD|strategy|HH:MM`. For each backtest trade, find matching actual trade by key. Handle scaling:
   - `raw`: use `trade.pl` as-is
   - `perContract`: divide `trade.pl` by `trade.numContracts` (or 1 if 0)
   - `toReported`: scale backtest PL by `actualContracts / backtestContracts`
   Track unmatched trades per strategy.

2. **Date key formatting:** Use local time methods per CLAUDE.md. `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`. For time: extract `HH:MM` from `timeOpened` string (first 5 chars), default to `'00:00'` if missing.

3. **Overlap date range:** Compute the intersection of backtest and actual date ranges. Filter trades to overlap period before computing metrics. If no overlap, return empty results with appropriate warnings.

4. **Direction agreement:** Group matched trades by `dateKey|strategy`. Sum scaled PL per side per day+strategy. Compare signs: both >= 0 or both < 0 = agreement. Compute overall rate and per-strategy breakdown.

5. **Execution efficiency:** Per strategy: sum scaled actual PL / sum scaled backtest PL. `underperforming = efficiency !== null && efficiency < 1.0`. Compute `slippageStdDev` from per-trade differences using `std` from mathjs with 'uncorrected' (sample std dev), or null if < 2 matched trades.

6. **Alignment trend:** Group matched pairs by month key (`YYYY-MM`). For each month compute direction agreement rate and efficiency ratio. Use `computeTrends` from `trend-detection.ts` for regression. `sufficientForTrends = monthlyPoints >= 4`.

7. **Data quality:** Report counts, match rate (`matched / min(backtest, actual)` within overlap), overlap months, date ranges, warnings. Add warning if match rate < 50%. Add warning if no overlap period.

8. **Empty/edge cases:** If either trade array is empty, return result with zero counts and appropriate warnings. If no matches found, return zero rates with warning.

**Important constraints:**
- Output raw metrics only, no interpretive labels or thresholds (per CONTEXT.md)
- Do NOT use `toISOString()` for dates
- Do NOT import from `packages/mcp-server/` -- inline the matching logic

**Barrel export:** Add `export * from './live-alignment'` to `packages/lib/calculations/index.ts` (after the `walk-forward-degradation` export).
  </action>
  <verify>
Run `npm test -- tests/unit/live-alignment.test.ts` -- all tests pass.
Run `cd /Users/davidromeo/Code/tradeblocks && npx tsc --noEmit -p packages/lib/tsconfig.json` -- no type errors.
  </verify>
  <done>
`analyzeLiveAlignment` correctly computes direction agreement, execution efficiency, and alignment trends from Trade[] and ReportingTrade[] inputs. All types are exported. Barrel export updated. Tests cover: basic matching, direction agreement calculation, per-strategy efficiency, monthly trend detection, perContract/raw/toReported scaling modes, empty inputs, no-overlap case, and insufficient data for trends.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write comprehensive unit tests</name>
  <files>
    tests/unit/live-alignment.test.ts
  </files>
  <action>
Create `tests/unit/live-alignment.test.ts` with comprehensive test coverage. Use the same test patterns as existing tests in `tests/unit/` (Jest, TypeScript, mock trade data).

**Test structure:**

```typescript
import { analyzeLiveAlignment } from '@tradeblocks/lib'
import type { Trade, ReportingTrade } from '@tradeblocks/lib'
```

**Helper:** Create `makeTrade(overrides)` and `makeReportingTrade(overrides)` factory functions for clean test data. Use dates like `new Date(2024, 0, 15)` (local time constructors) to avoid timezone issues.

**Test cases:**

1. **Empty inputs:**
   - Empty backtest trades returns zero counts, empty byStrategy arrays
   - Empty actual trades returns zero counts, empty byStrategy arrays
   - Both empty returns zero counts

2. **Basic matching and direction agreement:**
   - Two matched trades same day same strategy, both positive -> 100% agreement
   - Two matched trades same day same strategy, opposite signs -> 0% agreement
   - Mixed: 3 days, 2 agree, 1 disagrees -> ~66.7% agreement
   - Multiple strategies: per-strategy rates computed independently

3. **Execution efficiency:**
   - Backtest PL $100, actual PL $80 per contract -> efficiency 0.8
   - Per-contract gap computed correctly
   - Strategy with zero backtest PL -> efficiency null
   - `underperforming` flag: true when efficiency < 1.0, false when >= 1.0

4. **Scaling modes:**
   - `perContract`: PL divided by numContracts
   - `raw`: PL used as-is
   - `toReported`: backtest PL scaled by actualContracts/backtestContracts ratio

5. **Alignment trend:**
   - 6 months of matched trades produces monthlySeries with 6 entries
   - Trends computed via linear regression (directionTrend, efficiencyTrend not null)
   - < 4 months: sufficientForTrends = false, trends are null

6. **Data quality:**
   - matchRate computed correctly (matched / min(backtest, actual) within overlap)
   - overlapDateRange computed as intersection of date ranges
   - Unmatched trades counted per strategy
   - Warnings generated for low match rate

7. **Overlap filtering:**
   - Backtest 2022-2025, actual 2024-2025 -> overlap is 2024-2025
   - Metrics computed only within overlap period
   - No overlap -> appropriate warning, zero metrics

8. **Unmatched trade tracking:**
   - Backtest trade with no actual match -> counted in unmatchedBacktest
   - Actual trade with no backtest match -> counted in unmatchedActual
  </action>
  <verify>
Run `npm test -- tests/unit/live-alignment.test.ts` -- all tests pass with 0 failures.
Run `npm test -- tests/unit/live-alignment.test.ts --coverage` -- verify coverage of key branches.
  </verify>
  <done>
Test file covers all core behaviors: matching, direction agreement, execution efficiency, scaling modes, alignment trends, data quality, overlap filtering, and edge cases. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npm test -- tests/unit/live-alignment.test.ts` passes all tests
2. `npx tsc --noEmit -p packages/lib/tsconfig.json` compiles without errors
3. `analyzeLiveAlignment` is importable from `@tradeblocks/lib`
4. Direction agreement, execution efficiency, and alignment trend all produce correct values for test fixtures
</verification>

<success_criteria>
- `analyzeLiveAlignment(backtestTrades, actualTrades, { scaling: 'perContract' })` returns a `LiveAlignmentResult` with direction agreement rate, per-strategy execution efficiency, and monthly alignment trends
- All exported types compile correctly
- Test suite has at least 15 test cases covering all branches
- No imports from `packages/mcp-server/`
</success_criteria>

<output>
After completion, create `.planning/phases/49-live-alignment-signal/49-01-SUMMARY.md`
</output>
