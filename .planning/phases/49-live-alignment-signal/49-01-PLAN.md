---
phase: 49-live-alignment-signal
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/lib/calculations/trade-matching.ts
  - packages/lib/calculations/live-alignment.ts
  - packages/lib/calculations/index.ts
  - packages/mcp-server/src/tools/reports/slippage-helpers.ts
  - packages/mcp-server/src/tools/performance.ts
  - tests/unit/live-alignment.test.ts
autonomous: true

must_haves:
  truths:
    - "Trade matching functions (matchTrades, calculateScaledPl, formatDateKey, truncateTimeToMinute, etc.) live in packages/lib/calculations/trade-matching.ts as pure functions"
    - "slippage-helpers.ts re-exports all functions from @tradeblocks/lib so existing MCP consumers (discrepancies, slippage-trends, strategy-matches) continue working with zero import changes"
    - "Given backtest and actual trades, direction agreement rate is calculated per strategy and overall"
    - "Given backtest and actual trades, per-contract execution efficiency is calculated per strategy"
    - "Given matched trades over multiple months, alignment trend regression detects improving or degrading execution"
    - "Given insufficient monthly data points (<4), trends return null with sufficientForTrends=false"
    - "Data quality metrics report match rate, overlap date range, and unmatched trade counts"
    - "performance.ts compare_backtest_to_actual uses shared formatDateKey, truncateTimeToMinute, applyStrategyFilter, applyDateRangeFilter, and calculateScaledPl from @tradeblocks/lib instead of inline duplicates"
  artifacts:
    - path: "packages/lib/calculations/trade-matching.ts"
      provides: "Pure trade matching and scaling functions extracted from MCP server"
      exports: ["matchTrades", "calculateScaledPl", "formatDateKey", "truncateTimeToMinute", "parseHourFromTime", "getIsoWeekKey", "getMonthKey", "applyDateRangeFilter", "applyStrategyFilter", "getCorrelationInterpretation", "getConfidenceLevel", "MatchedTradeData"]
    - path: "packages/lib/calculations/live-alignment.ts"
      provides: "Pure function calculation engine for live alignment signals"
      exports: ["analyzeLiveAlignment", "LiveAlignmentResult", "LiveAlignmentSkipped", "LiveAlignmentOutput", "LiveAlignmentOptions"]
    - path: "packages/lib/calculations/index.ts"
      provides: "Barrel export including trade-matching and live-alignment"
      contains: "trade-matching"
    - path: "packages/mcp-server/src/tools/reports/slippage-helpers.ts"
      provides: "Re-export shim preserving existing consumer imports"
      contains: "from.*@tradeblocks/lib"
    - path: "packages/mcp-server/src/tools/performance.ts"
      provides: "compare_backtest_to_actual refactored to use shared utilities from @tradeblocks/lib"
      contains: "import.*formatDateKey.*from.*@tradeblocks/lib"
    - path: "tests/unit/live-alignment.test.ts"
      provides: "Unit tests for all live alignment calculations"
      min_lines: 100
  key_links:
    - from: "packages/lib/calculations/live-alignment.ts"
      to: "packages/lib/calculations/trade-matching.ts"
      via: "import matchTrades, calculateScaledPl, formatDateKey, truncateTimeToMinute"
      pattern: "import.*matchTrades.*from.*trade-matching"
    - from: "packages/lib/calculations/live-alignment.ts"
      to: "packages/lib/calculations/trend-detection.ts"
      via: "import computeTrends"
      pattern: "import.*computeTrends.*from.*trend-detection"
    - from: "packages/lib/calculations/live-alignment.ts"
      to: "packages/lib/models/trade.ts"
      via: "import Trade type"
      pattern: "import.*Trade.*from.*models/trade"
    - from: "packages/lib/calculations/live-alignment.ts"
      to: "packages/lib/models/reporting-trade.ts"
      via: "import ReportingTrade type"
      pattern: "import.*ReportingTrade.*from.*models/reporting-trade"
    - from: "packages/mcp-server/src/tools/reports/slippage-helpers.ts"
      to: "packages/lib/calculations/trade-matching.ts"
      via: "re-export from @tradeblocks/lib"
      pattern: "from.*@tradeblocks/lib"
    - from: "packages/mcp-server/src/tools/performance.ts"
      to: "packages/lib/calculations/trade-matching.ts"
      via: "import shared utilities from @tradeblocks/lib"
      pattern: "import.*formatDateKey.*from.*@tradeblocks/lib"
---

<objective>
Extract trade matching logic to packages/lib/, then create the live alignment calculation engine that derives direction agreement, execution efficiency, and alignment trend signals from backtest vs actual trade comparison.

Purpose: Consolidates duplicated trade matching logic into the shared lib layer (eliminating architectural debt), refactors the existing `compare_backtest_to_actual` tool to use the shared utilities, then builds the fourth signal category (live alignment) for Phase 50's unified edge decay verdict.
Output: Trade matching module in lib, live alignment engine in lib, re-export shim in MCP server, performance.ts refactored to shared utilities, comprehensive tests.
</objective>

<execution_context>
@/Users/davidromeo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidromeo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-live-alignment-signal/49-RESEARCH.md

# Source files to extract from and build upon
@packages/mcp-server/src/tools/reports/slippage-helpers.ts
@packages/mcp-server/src/tools/performance.ts
@packages/lib/calculations/walk-forward-degradation.ts
@packages/lib/calculations/trend-detection.ts
@packages/lib/calculations/index.ts
@packages/lib/models/trade.ts
@packages/lib/models/reporting-trade.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract trade matching logic from MCP server to lib</name>
  <files>
    packages/lib/calculations/trade-matching.ts
    packages/lib/calculations/index.ts
    packages/mcp-server/src/tools/reports/slippage-helpers.ts
  </files>
  <action>
Extract all pure business logic functions from `packages/mcp-server/src/tools/reports/slippage-helpers.ts` into a new `packages/lib/calculations/trade-matching.ts` module. Then convert slippage-helpers.ts into a thin re-export shim.

**Step 1: Create `packages/lib/calculations/trade-matching.ts`**

Copy the entire contents of `slippage-helpers.ts` into this new file. The file already has zero MCP dependencies — its only import is `type { Trade, ReportingTrade } from "@tradeblocks/lib"`. Update that import to use relative paths since we're now inside the lib package:

```typescript
import type { Trade } from '../models/trade'
import type { ReportingTrade } from '../models/reporting-trade'
```

All functions and interfaces to move (preserve exact implementations):
- `formatDateKey(d: Date): string`
- `truncateTimeToMinute(time: string | undefined): string`
- `parseHourFromTime(timeOpened: string | undefined): number | null`
- `getIsoWeekKey(dateStr: string): string`
- `getMonthKey(dateStr: string): string`
- `interface MatchedTradeData`
- `applyDateRangeFilter<T>(trades: T[], dateRange?): T[]`
- `applyStrategyFilter<T>(trades: T[], strategy?): T[]`
- `calculateScaledPl(btPl, actualPl, btContracts, actualContracts, scaling): { scaledBtPl, scaledActualPl }`
- `matchTrades(backtestTrades, actualTrades, scaling): { matchedTrades, unmatchedBacktestCount, unmatchedActualCount }`
- `getCorrelationInterpretation(coeff: number): string`
- `getConfidenceLevel(n: number): "low" | "moderate" | "high"`

Update the module JSDoc to reflect its new home:
```typescript
/**
 * Trade Matching & Scaling Utilities
 *
 * Pure business logic for matching backtest trades to actual (reporting log)
 * trades and computing scaled P/L comparisons. Used by live alignment engine,
 * slippage analysis, and discrepancy analysis.
 */
```

**Step 2: Convert slippage-helpers.ts to a re-export shim**

Replace the entire contents of `packages/mcp-server/src/tools/reports/slippage-helpers.ts` with:

```typescript
/**
 * Slippage Analysis Helpers
 *
 * Re-exports from @tradeblocks/lib. All trade matching and scaling logic
 * has been consolidated into packages/lib/calculations/trade-matching.ts.
 *
 * This file preserves existing import paths for MCP server consumers.
 */

export {
  formatDateKey,
  truncateTimeToMinute,
  parseHourFromTime,
  getIsoWeekKey,
  getMonthKey,
  type MatchedTradeData,
  applyDateRangeFilter,
  applyStrategyFilter,
  calculateScaledPl,
  matchTrades,
  getCorrelationInterpretation,
  getConfidenceLevel,
} from "@tradeblocks/lib";
```

This preserves all three existing consumer import paths:
- `packages/mcp-server/src/tools/reports/discrepancies.ts` → `from "./slippage-helpers.js"` ✓
- `packages/mcp-server/src/tools/reports/slippage-trends.ts` → `from "./slippage-helpers.js"` ✓
- `packages/mcp-server/src/tools/reports/strategy-matches.ts` → `from "./slippage-helpers.js"` ✓

**Step 3: Add barrel export in `packages/lib/calculations/index.ts`**

Add `export * from './trade-matching'` after the `walk-forward-degradation` export line.

**Verification approach:** After this task, run the full test suite to confirm zero regressions — every existing consumer still works via the re-export shim.
  </action>
  <verify>
Run `npm test` -- full test suite passes with zero regressions.
Run `cd /Users/davidromeo/Code/tradeblocks/packages/mcp-server && npm run build` -- MCP server builds cleanly.
Run `cd /Users/davidromeo/Code/tradeblocks && npx tsc --noEmit -p packages/lib/tsconfig.json` -- lib compiles without errors.
  </verify>
  <done>
All trade matching functions extracted to `packages/lib/calculations/trade-matching.ts`. `slippage-helpers.ts` is now a re-export shim. Full test suite passes with zero regressions. MCP server builds cleanly. All existing consumers (`discrepancies.ts`, `slippage-trends.ts`, `strategy-matches.ts`) work unchanged via re-export.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement live alignment calculation engine</name>
  <files>
    packages/lib/calculations/live-alignment.ts
    packages/lib/calculations/index.ts
  </files>
  <action>
Create `packages/lib/calculations/live-alignment.ts` as a pure function calculation engine following the pattern from `walk-forward-degradation.ts`. The engine imports matching logic from the sibling `trade-matching.ts` module (extracted in Task 1) — no inlining, no duplication.

**Main export:**
```typescript
export function analyzeLiveAlignment(
  backtestTrades: Trade[],
  actualTrades: ReportingTrade[],
  options?: LiveAlignmentOptions
): LiveAlignmentResult
```

**Types to export:**
- `LiveAlignmentOptions` with optional `scaling: 'raw' | 'perContract' | 'toReported'` (default: `perContract`)
- `LiveAlignmentResult` with `available: true`, `overlapDateRange`, `directionAgreement`, `executionEfficiency`, `alignmentTrend`, `dataQuality`
- `LiveAlignmentSkipped` with `available: false, reason: string`
- `LiveAlignmentOutput = LiveAlignmentResult | LiveAlignmentSkipped`
- `DirectionAgreementResult` with `overallRate`, `totalDays`, `agreementDays`, `byStrategy` array
- `ExecutionEfficiencyResult` with `overallEfficiency`, `totalActualPl`, `totalBacktestPl`, `byStrategy` array (each with `efficiency`, `perContractGap`, `actualPerContract`, `backtestPerContract`, `matchedTrades`, `unmatchedBacktest`, `unmatchedActual`, `underperforming`, `slippageStdDev`)
- `AlignmentTrendResult` with `monthlySeries` array, `directionTrend: TrendResult | null`, `efficiencyTrend: TrendResult | null`, `sufficientForTrends: boolean`
- `AlignmentDataQuality` with `backtestTradeCount`, `actualTradeCount`, `matchedTradeCount`, `matchRate`, `overlapMonths`, `backtestDateRange`, `actualDateRange`, `overlapDateRange`, `sufficientForTrends`, `warnings` array

**Key imports from sibling modules (NO duplication):**
```typescript
import { matchTrades, calculateScaledPl, formatDateKey, truncateTimeToMinute, getMonthKey } from './trade-matching'
import { computeTrends } from './trend-detection'
import type { TrendResult } from './trend-detection'
import type { Trade } from '../models/trade'
import type { ReportingTrade } from '../models/reporting-trade'
```

**Implementation details:**

1. **Trade matching:** Use `matchTrades(backtestTrades, actualTrades, scaling)` from `trade-matching.ts` — no inlining needed. This returns `matchedTrades` array with `date`, `strategy`, `timeOpened`, `totalSlippage`, plus `unmatchedBacktestCount` and `unmatchedActualCount`.

2. **Additional per-trade data needed:** `matchTrades` returns `MatchedTradeData` which has `totalSlippage` but not the individual scaled P/L values. For execution efficiency you need per-trade scaled backtest and actual P&L. Two approaches:
   - Call `calculateScaledPl` directly on each matched pair to get individual values
   - Or build a parallel matching pass that tracks individual P&L

   **Recommended approach:** Build a lightweight matching pass alongside `matchTrades` that tracks per-strategy aggregates. Use `formatDateKey` and `truncateTimeToMinute` from `trade-matching.ts` to build keys, then iterate similarly to `matchTrades` but accumulate per-strategy scaled PL sums directly. This avoids modifying `matchTrades` while reusing its key-generation utilities.

3. **Overlap date range:** Compute the intersection of backtest and actual date ranges using `formatDateKey`. Filter trades to overlap period before computing metrics. If no overlap, return empty results with appropriate warnings.

4. **Direction agreement:** Group matched trades by `date|strategy`. Sum scaled PL per side per day+strategy. Compare signs: both >= 0 or both < 0 = agreement. Compute overall rate and per-strategy breakdown.

5. **Execution efficiency:** Per strategy: sum scaled actual PL / sum scaled backtest PL. `underperforming = efficiency !== null && efficiency < 1.0`. Compute `slippageStdDev` from per-trade slippage differences using `std` from mathjs with 'uncorrected' (sample std dev), or null if < 2 matched trades.

6. **Alignment trend:** Group matched pairs by month key using `getMonthKey`. For each month compute direction agreement rate and efficiency ratio. Use `computeTrends` from `trend-detection.ts` for regression. `sufficientForTrends = monthlyPoints >= 4`.

7. **Data quality:** Report counts, match rate (`matched / min(backtest, actual)` within overlap), overlap months, date ranges, warnings. Add warning if match rate < 50%. Add warning if no overlap period.

8. **Empty/edge cases:** If either trade array is empty, return result with zero counts and appropriate warnings. If no matches found, return zero rates with warning.

**Important constraints:**
- Output raw metrics only, no interpretive labels or thresholds (per CONTEXT.md)
- Do NOT use `toISOString()` for dates — use `formatDateKey` from `trade-matching.ts`
- Import matching utilities from `./trade-matching`, NOT from `packages/mcp-server/`

**Barrel export:** Add `export * from './live-alignment'` to `packages/lib/calculations/index.ts` (after the `trade-matching` export added in Task 1).
  </action>
  <verify>
Run `cd /Users/davidromeo/Code/tradeblocks && npx tsc --noEmit -p packages/lib/tsconfig.json` -- no type errors.
  </verify>
  <done>
`analyzeLiveAlignment` correctly computes direction agreement, execution efficiency, and alignment trends from Trade[] and ReportingTrade[] inputs using shared `matchTrades` and `calculateScaledPl` from `trade-matching.ts` — zero duplicated matching logic. All types are exported. Barrel export updated.
  </done>
</task>

<task type="auto">
  <name>Task 3: Write comprehensive unit tests</name>
  <files>
    tests/unit/live-alignment.test.ts
  </files>
  <action>
Create `tests/unit/live-alignment.test.ts` with comprehensive test coverage. Use the same test patterns as existing tests in `tests/unit/` (Jest, TypeScript, mock trade data).

**Test structure:**

```typescript
import { analyzeLiveAlignment } from '@tradeblocks/lib'
import type { Trade, ReportingTrade } from '@tradeblocks/lib'
```

**Helper:** Create `makeTrade(overrides)` and `makeReportingTrade(overrides)` factory functions for clean test data. Use dates like `new Date(2024, 0, 15)` (local time constructors) to avoid timezone issues.

**Test cases:**

1. **Empty inputs:**
   - Empty backtest trades returns zero counts, empty byStrategy arrays
   - Empty actual trades returns zero counts, empty byStrategy arrays
   - Both empty returns zero counts

2. **Basic matching and direction agreement:**
   - Two matched trades same day same strategy, both positive -> 100% agreement
   - Two matched trades same day same strategy, opposite signs -> 0% agreement
   - Mixed: 3 days, 2 agree, 1 disagrees -> ~66.7% agreement
   - Multiple strategies: per-strategy rates computed independently

3. **Execution efficiency:**
   - Backtest PL $100, actual PL $80 per contract -> efficiency 0.8
   - Per-contract gap computed correctly
   - Strategy with zero backtest PL -> efficiency null
   - `underperforming` flag: true when efficiency < 1.0, false when >= 1.0

4. **Scaling modes:**
   - `perContract`: PL divided by numContracts
   - `raw`: PL used as-is
   - `toReported`: backtest PL scaled by actualContracts/backtestContracts ratio

5. **Alignment trend:**
   - 6 months of matched trades produces monthlySeries with 6 entries
   - Trends computed via linear regression (directionTrend, efficiencyTrend not null)
   - < 4 months: sufficientForTrends = false, trends are null

6. **Data quality:**
   - matchRate computed correctly (matched / min(backtest, actual) within overlap)
   - overlapDateRange computed as intersection of date ranges
   - Unmatched trades counted per strategy
   - Warnings generated for low match rate

7. **Overlap filtering:**
   - Backtest 2022-2025, actual 2024-2025 -> overlap is 2024-2025
   - Metrics computed only within overlap period
   - No overlap -> appropriate warning, zero metrics

8. **Unmatched trade tracking:**
   - Backtest trade with no actual match -> counted in unmatchedBacktest
   - Actual trade with no backtest match -> counted in unmatchedActual
  </action>
  <verify>
Run `npm test -- tests/unit/live-alignment.test.ts` -- all tests pass with 0 failures.
Run `npm test` -- full test suite passes (confirms trade-matching extraction + live-alignment engine work together).
  </verify>
  <done>
Test file covers all core behaviors: matching, direction agreement, execution efficiency, scaling modes, alignment trends, data quality, overlap filtering, and edge cases. All tests pass. Full suite confirms zero regressions from trade-matching extraction.
  </done>
</task>

<task type="auto">
  <name>Task 4: Refactor compare_backtest_to_actual to use shared utilities</name>
  <files>
    packages/mcp-server/src/tools/performance.ts
  </files>
  <action>
Refactor `packages/mcp-server/src/tools/performance.ts` to import and use the shared utility functions from `@tradeblocks/lib` instead of inline duplicates. This is a surgical refactor — replace 5 utility functions at the edges, leave the matching loops and output logic untouched.

**IMPORTANT:** `performance.ts` is a large file (~2600 lines) with multiple tools. Read the full file before making changes to understand the scope.

**Step 1: Replace module-level `formatDateKey` (lines ~221-229)**

Delete the local `formatDateKey` function definition. Add it to the `@tradeblocks/lib` import at the top of the file:

```typescript
import {
  // ... existing imports ...
  formatDateKey,
  truncateTimeToMinute,
  calculateScaledPl,
  applyStrategyFilter,
  applyDateRangeFilter,
} from "@tradeblocks/lib";
```

`formatDateKey` is used by 25+ call sites throughout the file (across `get_performance_charts`, `get_period_returns`, `compare_backtest_to_actual`, and other tools). All call sites work unchanged since the function signature is identical.

**Step 2: Remove inline `truncateTimeToMinute` in `compare_backtest_to_actual` handler (~line 1920)**

Delete the inline arrow function:
```typescript
// DELETE THIS:
const truncateTimeToMinute = (time: string | undefined): string => {
  if (!time) return "00:00";
  const parts = time.split(":");
  if (parts.length >= 2) {
    return `${parts[0].padStart(2, "0")}:${parts[1].padStart(2, "0")}`;
  }
  return "00:00";
};
```

The import from Step 1 provides the identical function. All call sites within the handler work unchanged.

**Step 3: Replace inline strategy filtering (~lines 1868-1875)**

Replace:
```typescript
if (strategy) {
  backtestTrades = backtestTrades.filter(
    (t) => t.strategy.toLowerCase() === strategy.toLowerCase()
  );
  actualTrades = actualTrades.filter(
    (t) => t.strategy.toLowerCase() === strategy.toLowerCase()
  );
}
```

With:
```typescript
backtestTrades = applyStrategyFilter(backtestTrades, strategy);
actualTrades = applyStrategyFilter(actualTrades, strategy);
```

**Step 4: Replace inline date range filtering (~lines 1878-1893)**

Replace:
```typescript
if (dateRange) {
  if (dateRange.from || dateRange.to) {
    backtestTrades = backtestTrades.filter((t) => {
      const tradeDate = formatDateKey(new Date(t.dateOpened));
      if (dateRange.from && tradeDate < dateRange.from) return false;
      if (dateRange.to && tradeDate > dateRange.to) return false;
      return true;
    });
    actualTrades = actualTrades.filter((t) => {
      const tradeDate = formatDateKey(new Date(t.dateOpened));
      if (dateRange.from && tradeDate < dateRange.from) return false;
      if (dateRange.to && tradeDate > dateRange.to) return false;
      return true;
    });
  }
}
```

With:
```typescript
backtestTrades = applyDateRangeFilter(backtestTrades, dateRange);
actualTrades = applyDateRangeFilter(actualTrades, dateRange);
```

**Step 5: Replace inline scaling math in trade-level mode (~lines 2033-2056)**

Replace the inline scaling block with `calculateScaledPl`. The inline version also extracts `scalingFactor` which `calculateScaledPl` doesn't return, so compute it separately:

```typescript
const { scaledBtPl, scaledActualPl } = calculateScaledPl(
  btTrade.pl, actualTrade.pl,
  btTrade.numContracts, actualTrade.numContracts,
  scaling
);
const scalingFactor = scaling === "toReported" && btTrade.numContracts > 0 && actualTrade.numContracts > 0
  ? actualTrade.numContracts / btTrade.numContracts
  : 1;
```

Then use `scaledActualPl` instead of the separately-computed `actualPl` variable. Update references downstream in the `DetailedComparison` construction to use `scaledBtPl` and `scaledActualPl`.

**Step 6: Replace inline scaling math in summary mode (~lines 2265-2281)**

Apply the same `calculateScaledPl` pattern to the summary-mode scaling. The summary mode passes aggregated P&L totals and contract counts:

```typescript
const { scaledBtPl: scaledBtTotal, scaledActualPl: scaledActualTotal } = calculateScaledPl(
  btTotal, actualTotal,
  btContracts, actualContracts,
  scaling
);
const scalingFactor = scaling === "toReported" && btContracts > 0 && actualContracts > 0
  ? actualContracts / btContracts
  : 1;
```

**What NOT to change:**
- Matching loops (trade-level lines ~2003-2216 and summary-level lines ~2217-2354) — these produce `DetailedComparison` objects specific to this tool
- `getGroupKey` helper — uses `getISOWeekNumber` with different signature than shared `getIsoWeekKey`
- `getISOWeekNumber` function — used by `getGroupKey` and `get_period_returns`, different interface
- Outlier detection, grouping, output formatting — all unique to this tool
- Field-by-field diff construction — unique

**Net result:** ~50-60 lines of inline duplicate code removed, replaced by 5-6 import lines. All behavior is identical.
  </action>
  <verify>
Run `cd /Users/davidromeo/Code/tradeblocks/packages/mcp-server && npm run build` -- MCP server builds cleanly with no type errors.
Run `npm test` -- full test suite passes with zero regressions.
  </verify>
  <done>
`compare_backtest_to_actual` in performance.ts now uses `formatDateKey`, `truncateTimeToMinute`, `applyStrategyFilter`, `applyDateRangeFilter`, and `calculateScaledPl` from `@tradeblocks/lib` instead of inline duplicates. Local `formatDateKey` function definition removed (was used by entire file — all 25+ call sites now use the lib import). MCP server builds cleanly and all tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npm test` -- full test suite passes with zero regressions (confirms extraction + refactor didn't break anything)
2. `npm test -- tests/unit/live-alignment.test.ts` passes all new tests
3. `npx tsc --noEmit -p packages/lib/tsconfig.json` compiles without errors
4. `cd packages/mcp-server && npm run build` builds without errors
5. `analyzeLiveAlignment` is importable from `@tradeblocks/lib`
6. `matchTrades` is importable from both `@tradeblocks/lib` and `./slippage-helpers.js` (re-export shim works)
7. Direction agreement, execution efficiency, and alignment trend all produce correct values for test fixtures
8. `performance.ts` has no local `formatDateKey` definition — uses import from `@tradeblocks/lib`
9. `compare_backtest_to_actual` handler has no inline `truncateTimeToMinute` — uses import from `@tradeblocks/lib`
</verification>

<success_criteria>
- Trade matching logic consolidated in `packages/lib/calculations/trade-matching.ts` with zero behavior changes
- `slippage-helpers.ts` is a re-export shim — existing MCP consumers unchanged
- `compare_backtest_to_actual` in performance.ts uses shared `formatDateKey`, `truncateTimeToMinute`, `applyStrategyFilter`, `applyDateRangeFilter`, and `calculateScaledPl` from `@tradeblocks/lib`
- `analyzeLiveAlignment(backtestTrades, actualTrades, { scaling: 'perContract' })` returns a `LiveAlignmentResult` with direction agreement rate, per-strategy execution efficiency, and monthly alignment trends
- Live alignment engine imports from `./trade-matching` — zero duplicated matching logic
- All exported types compile correctly
- Test suite has at least 15 test cases covering all branches
- Full test suite passes with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/49-live-alignment-signal/49-01-SUMMARY.md`
</output>
