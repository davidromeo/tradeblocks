---
phase: 46-core-calculation-engines
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/lib/calculations/rolling-metrics.ts
  - packages/lib/calculations/index.ts
  - tests/unit/rolling-metrics.test.ts
autonomous: true

must_haves:
  truths:
    - "Rolling Sharpe, win rate, profit factor, Kelly %, avg return, and net P&L are computed over a configurable window with smart auto-calculated default"
    - "Quarterly seasonal averages (Q1/Q2/Q3/Q4) are computed for each rolling metric"
    - "Recent window vs full history comparison shows delta for each metric"
    - "Structural flags surface when payoff structure inverts (avg loss > avg win), win rate crosses below 50%, profit factor drops below 1.0, or Kelly goes negative"
    - "Recent window supports both trade-count-based and time-based definitions"
  artifacts:
    - path: "packages/lib/calculations/rolling-metrics.ts"
      provides: "Rolling metrics engine with seasonal averages and recent-vs-historical comparison"
      exports: ["computeRollingMetrics", "compareRecentVsHistorical", "RollingMetricsResult", "RecentVsHistoricalComparison", "SeasonalAverages", "StructuralFlag"]
    - path: "tests/unit/rolling-metrics.test.ts"
      provides: "Test coverage for rolling metrics engine"
  key_links:
    - from: "packages/lib/calculations/rolling-metrics.ts"
      to: "packages/lib/calculations/portfolio-stats.ts"
      via: "PortfolioStatsCalculator for windowed metric computation"
      pattern: "PortfolioStatsCalculator"
    - from: "packages/lib/calculations/rolling-metrics.ts"
      to: "packages/lib/calculations/kelly.ts"
      via: "calculateKellyMetrics for rolling Kelly %"
      pattern: "calculateKellyMetrics"
    - from: "packages/lib/calculations/index.ts"
      to: "packages/lib/calculations/rolling-metrics.ts"
      via: "barrel export"
      pattern: "export \\* from './rolling-metrics'"
---

<objective>
Build the rolling metrics engine for edge decay analysis.

Purpose: Computes rolling window statistics over trade history, quarterly seasonal averages, and recent-vs-historical comparison with structural flags. This is the second foundational engine for Phase 46, consumed by the MCP tool in Plan 03 and by downstream phases (47-50).

Output: New calculation file (`rolling-metrics.ts`), barrel export update, and comprehensive tests.
</objective>

<execution_context>
@/Users/davidromeo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidromeo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/46-core-calculation-engines/46-CONTEXT.md
@.planning/phases/46-core-calculation-engines/46-RESEARCH.md
@packages/lib/calculations/portfolio-stats.ts
@packages/lib/calculations/kelly.ts
@packages/lib/calculations/performance.ts
@packages/lib/calculations/index.ts
@packages/lib/models/trade.ts
@packages/lib/models/portfolio-stats.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build rolling metrics engine</name>
  <files>
    packages/lib/calculations/rolling-metrics.ts
    packages/lib/calculations/index.ts
  </files>
  <action>
Create `packages/lib/calculations/rolling-metrics.ts` as a pure function module.

Import Trade from `../models/trade`, PortfolioStatsCalculator from `./portfolio-stats`, calculateKellyMetrics from `./kelly`.

**Key interfaces:**

```typescript
export interface RollingDataPoint {
  tradeIndex: number        // index of the last trade in this window
  date: string              // dateOpened of the last trade (local YYYY-MM-DD)
  windowSize: number        // actual number of trades in window
  winRate: number           // decimal 0-1
  profitFactor: number
  kellyPercent: number
  sharpeRatio: number | null  // null if insufficient data
  avgReturn: number         // avg trade P&L in window
  netPl: number             // sum of P&L in window
}

export interface SeasonalAverages {
  // Keyed by metric name, each contains Q1-Q4 averages
  [metricName: string]: {
    Q1: number | null   // null if no data for that quarter
    Q2: number | null
    Q3: number | null
    Q4: number | null
  }
}

export interface StructuralFlag {
  metric: string              // e.g. "profitFactor"
  recentValue: number
  historicalValue: number
  threshold: number           // the critical threshold crossed
  thresholdDescription: string // e.g. "below 1.0"
}

export interface RecentVsHistoricalComparison {
  recentWindow: {
    type: 'trade-count' | 'time-based'
    tradeCount: number
    dateRange: { start: string, end: string }
  }
  metrics: Array<{
    metric: string
    recentValue: number
    historicalValue: number
    delta: number             // recent - historical
    percentChange: number | null  // (recent - historical) / |historical| * 100, null if historical is 0
  }>
  structuralFlags: StructuralFlag[]
}

export interface RollingMetricsResult {
  windowSize: number          // actual window size used
  series: RollingDataPoint[]  // one entry per step (default: step = 1 trade)
  seasonalAverages: SeasonalAverages
  recentVsHistorical: RecentVsHistoricalComparison

  dataQuality: {
    totalTrades: number
    sufficientForRolling: boolean     // trades.length >= windowSize
    sufficientForRecentComparison: boolean  // trades.length > recentWindowSize
    warnings: string[]
  }
}

export interface RollingMetricsOptions {
  windowSize?: number          // default: auto-calculated
  recentWindowSize?: number    // default: auto-calculated (trade-count)
  recentWindowDays?: number    // override: time-based recent window
  step?: number                // default: 1 (compute at every trade)
}
```

**Main export: `computeRollingMetrics(trades: Trade[], options?: RollingMetricsOptions): RollingMetricsResult`**

Implementation:

1. **Sort trades** chronologically by dateOpened using local time (getFullYear, getMonth, getDate). If same date, sort by timeOpened.

2. **Calculate smart defaults:**
   - `windowSize`: if not provided, use `calculateDefaultWindowSize(tradeCount)`:
     ```typescript
     function calculateDefaultWindowSize(tradeCount: number): number {
       const twentyPercent = Math.round(tradeCount * 0.2)
       return Math.max(20, Math.min(200, twentyPercent))
     }
     ```
   - `recentWindowSize`: if neither recentWindowSize nor recentWindowDays provided, use:
     ```typescript
     function calculateDefaultRecentWindow(tradeCount: number): number {
       const twentyPercent = Math.round(tradeCount * 0.2)
       const defaultN = Math.max(twentyPercent, 200)
       return Math.min(defaultN, tradeCount)
     }
     ```

3. **Compute rolling series:**
   - Slide a window of `windowSize` trades across the sorted array, stepping by `step` (default 1).
   - For each window position (from index `windowSize-1` to `trades.length-1`):
     - Extract the window slice: `trades.slice(i - windowSize + 1, i + 1)`
     - Compute metrics on the window:
       - `winRate`: count(pl > 0) / windowSize
       - `profitFactor`: sum(wins) / |sum(losses)|, or Infinity if no losses, 0 if no wins
       - `kellyPercent`: via `calculateKellyMetrics(windowTrades).percent`
       - `sharpeRatio`: use `PortfolioStatsCalculator` on window trades. If the calculator returns `sharpeRatio` of 0 or undefined with < 5 trades, set to null.
       - `avgReturn`: mean(pl values in window)
       - `netPl`: sum(pl values in window)
     - Record the data point with the last trade's date (format as YYYY-MM-DD using local time).
   - **Performance optimization**: For winRate, profitFactor, avgReturn, netPl -- use an incremental sliding window approach rather than recalculating from scratch each time. Track counts of wins/losses and running sums, subtract the outgoing trade and add the incoming trade.
   - For sharpeRatio and kellyPercent, recalculate from scratch since they're more complex. But only recalculate Sharpe every `Math.max(1, Math.floor(windowSize / 10))` steps to reduce computation (interpolate or carry forward between).
   - Actually, for simplicity and correctness, just recalculate all metrics fresh for each window. The performance cost is acceptable for typical trade counts (< 5000 trades). Only optimize if profiling shows issues.

4. **Compute seasonal averages:**
   - From the rolling series data points, group by calendar quarter of the `date` field.
   - Quarter mapping: Jan-Mar = Q1, Apr-Jun = Q2, Jul-Sep = Q3, Oct-Dec = Q4.
   - For each metric (winRate, profitFactor, kellyPercent, sharpeRatio, avgReturn, netPl), compute the mean of all rolling data points that fall in that quarter.
   - Return as `SeasonalAverages` keyed by metric name.

5. **Compute recent vs historical comparison:**
   - Determine recent window:
     - If `recentWindowDays` is provided, find trades within the last N calendar days of the dataset.
     - Otherwise, use last `recentWindowSize` trades.
   - Split trades into `recentTrades` (the window) and `historicalTrades` (everything before).
   - Compute metrics for each group using PortfolioStatsCalculator + calculateKellyMetrics:
     - winRate, profitFactor, kellyPercent, sharpeRatio, avgReturn (mean P&L), netPl, avgWin (from calculateKellyMetrics), avgLoss (from calculateKellyMetrics)
   - Build comparison array with delta = recent - historical for each metric.
   - **Structural flags** -- check these conditions on the RECENT window:
     - Payoff inversion: if recent avgLoss > recent avgWin (both as absolute values). Threshold: "avg loss exceeds avg win".
     - Win rate below 50%: recentWinRate < 0.5 AND historicalWinRate >= 0.5. Threshold: 0.5.
     - Profit factor below 1.0: recentPF < 1.0 AND historicalPF >= 1.0. Threshold: 1.0.
     - Kelly negative: recentKelly < 0 AND historicalKelly >= 0. Threshold: 0.
   - Each flag includes the factual values and threshold description.

6. **Data quality:**
   - `sufficientForRolling`: trades.length >= windowSize
   - `sufficientForRecentComparison`: trades.length > recentWindowSize (need some historical trades beyond the recent window)
   - Warnings: "Only N trades available, window size is W" if insufficient, etc.

**Also export the helper:** `compareRecentVsHistorical(trades: Trade[], recentCount?: number, recentDays?: number): RecentVsHistoricalComparison` -- for use by other phases that may want just the comparison without rolling series.

**Update `packages/lib/calculations/index.ts`:**
Add `export * from './rolling-metrics'` after the period-segmentation export (or wherever the alphabetical/logical order fits -- place it near trend-detection and period-segmentation).

NOTE: Plan 01 also modifies index.ts. Since both plans run in Wave 1, there's a potential file conflict. To handle this cleanly: this plan should READ the current index.ts and ADD its export line. If plan 01's changes are already present, add after them. If not, add in a sensible location. The exports are independent lines so merge conflicts are trivial.

IMPORTANT constraints:
- NO interpretive labels. Structural flags use factual descriptions ("below 1.0"), not judgments.
- Use local time methods for date handling.
- Rolling Sharpe computation: use PortfolioStatsCalculator which internally handles risk-free rates correctly.
- For the comparison, compute avgWin and avgLoss from the Kelly metrics (they're already calculated there as absolute values).
  </action>
  <verify>
Run `npm run build --workspace=packages/lib` to confirm no TypeScript errors. Check that the new exports are accessible.
  </verify>
  <done>
- `rolling-metrics.ts` exports `computeRollingMetrics` and `compareRecentVsHistorical`
- Rolling series computed over configurable window with smart defaults
- Seasonal averages computed for Q1-Q4 across all metrics
- Recent vs historical comparison includes delta and structural flags
- Smart auto-defaults: 20% of trade count clamped to [20, 200] for window, [max(20%, 200), tradeCount] for recent
- index.ts updated with new export
  </done>
</task>

<task type="auto">
  <name>Task 2: Test rolling metrics engine</name>
  <files>
    tests/unit/rolling-metrics.test.ts
  </files>
  <action>
Create comprehensive tests for the rolling metrics engine. Use the same `makeTrade` helper pattern as the period-segmentation tests (or import from a shared test utility if plan 01 extracted one).

```typescript
import { computeRollingMetrics, compareRecentVsHistorical } from '@tradeblocks/lib'
import type { Trade } from '@tradeblocks/lib'
```

**Test cases for `computeRollingMetrics`:**

1. **Empty trades**: returns empty series, dataQuality shows insufficient data
2. **Fewer trades than window size**: series is empty, dataQuality.sufficientForRolling is false, warning present
3. **Exact window size trades (e.g., 20)**: produces exactly 1 rolling data point
4. **Smart default window size**:
   - 100 trades -> window = max(20, min(200, 20)) = 20
   - 500 trades -> window = max(20, min(200, 100)) = 100
   - 2000 trades -> window = max(20, min(200, 400)) = 200
5. **Rolling series length**: N trades with window W produces N-W+1 data points (when step=1)
6. **Metric correctness for known data**: create 30 trades where first 20 are all winners (pl=100) and last 10 are all losers (pl=-50). Window of 20:
   - First rolling point (trades 0-19): winRate = 1.0, profitFactor = Infinity (or very large)
   - Last rolling point (trades 10-29): winRate = 10/20 = 0.5, profitFactor = (10*100) / (10*50) = 2.0
7. **Custom window size**: provide explicit windowSize=10, verify it's used instead of auto-default
8. **Step parameter**: step=5 with 100 trades and window=20 should produce roughly (100-20)/5 + 1 = ~17 data points

**Test cases for seasonal averages:**
9. **Trades across all 4 quarters**: verify Q1-Q4 averages are populated
10. **Trades in only 2 quarters**: missing quarters show null

**Test cases for `compareRecentVsHistorical`:**
11. **Basic comparison**: 200 trades total, recent=50. Verify historical uses first 150, recent uses last 50. Metrics computed for both.
12. **Delta computation**: historical winRate=0.6, recent winRate=0.4 -> delta=-0.2
13. **Time-based recent window**: provide recentWindowDays=90, verify trades are selected by date range not count

**Test cases for structural flags:**
14. **Payoff inversion**: create recent trades where avgLoss > avgWin, historical where avgWin > avgLoss. Flag should fire.
15. **Win rate below 50%**: recent winRate < 0.5, historical >= 0.5. Flag fires.
16. **Profit factor below 1.0**: recent PF < 1, historical >= 1. Flag fires.
17. **Kelly negative**: recent Kelly < 0, historical >= 0. Flag fires.
18. **No flags when conditions not met**: all-positive recent metrics. No structural flags.
19. **Flag only fires on CROSSING**: if historical was already below threshold, flag should NOT fire (e.g., historical PF was already 0.8, recent PF is 0.7 -- no flag since historical was already below 1.0)

**Edge cases:**
20. **All trades winning**: no losses, profitFactor should handle gracefully (Infinity or very large number)
21. **All trades losing**: no wins, winRate = 0, test doesn't crash

Run tests: `npm test -- tests/unit/rolling-metrics.test.ts`
  </action>
  <verify>
`npm test -- tests/unit/rolling-metrics.test.ts` passes with all tests green.
  </verify>
  <done>
- At least 18 test cases covering computeRollingMetrics, seasonal averages, compareRecentVsHistorical, structural flags, and edge cases
- Smart defaults verified for different trade counts
- Structural flag crossing logic tested (only flags on threshold crossing, not pre-existing condition)
- All tests pass
  </done>
</task>

</tasks>

<verification>
1. `npm run build --workspace=packages/lib` succeeds with no errors
2. `npm test -- tests/unit/rolling-metrics.test.ts` -- all tests pass
3. `npm test` -- full test suite still passes (no regressions)
4. No interpretive labels in rolling-metrics.ts (grep for "improving", "deteriorating", "stable", "degrading" -- should return nothing)
</verification>

<success_criteria>
- Rolling metrics engine computes rolling series of 6+ metrics over configurable window
- Smart auto-defaults for window size and recent window size
- Quarterly seasonal averages computed for each rolling metric
- Recent vs historical comparison with deltas and 4 structural flags
- Both trade-count and time-based recent window definitions supported
- Tests cover at least 18 scenarios with all passing
</success_criteria>

<output>
After completion, create `.planning/phases/46-core-calculation-engines/46-02-SUMMARY.md`
</output>
