---
phase: 46-core-calculation-engines
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/lib/calculations/trend-detection.ts
  - packages/lib/calculations/period-segmentation.ts
  - packages/lib/calculations/index.ts
  - tests/unit/period-segmentation.test.ts
autonomous: true

must_haves:
  truths:
    - "Given a block's trades, the engine produces yearly, quarterly, and monthly breakdowns of win rate, profit factor, Kelly %, Sharpe, avg monthly return as % of equity, trade count, and net P&L"
    - "Year-over-year trend direction is detected via linear regression returning slope, R-squared, p-value, and sample size for ALL period metrics"
    - "The worst consecutive-month losing stretch is identified with both all-time worst AND currently active streak flagged"
    - "Partial periods are annotated with isPartial flag and actual days/trade count"
  artifacts:
    - path: "packages/lib/calculations/period-segmentation.ts"
      provides: "Period segmentation engine with yearly/quarterly/monthly breakdowns"
      exports: ["segmentByPeriod", "findWorstConsecutiveLosingMonths", "PeriodSegmentationResult", "PeriodMetrics", "ConsecutiveLosingStretch"]
    - path: "packages/lib/calculations/trend-detection.ts"
      provides: "Linear regression trend detection extracted from slippage-trends.ts"
      exports: ["linearRegression", "computeTrends", "TrendResult", "TrendAnalysis"]
    - path: "tests/unit/period-segmentation.test.ts"
      provides: "Test coverage for period segmentation and trend detection"
  key_links:
    - from: "packages/lib/calculations/period-segmentation.ts"
      to: "packages/lib/calculations/portfolio-stats.ts"
      via: "PortfolioStatsCalculator.calculatePortfolioStats for per-period metrics"
      pattern: "new PortfolioStatsCalculator"
    - from: "packages/lib/calculations/period-segmentation.ts"
      to: "packages/lib/calculations/kelly.ts"
      via: "calculateKellyMetrics for per-period Kelly %"
      pattern: "calculateKellyMetrics"
    - from: "packages/lib/calculations/period-segmentation.ts"
      to: "packages/lib/calculations/trend-detection.ts"
      via: "computeTrends for regression on period metric series"
      pattern: "computeTrends"
    - from: "packages/lib/calculations/index.ts"
      to: "packages/lib/calculations/period-segmentation.ts"
      via: "barrel export"
      pattern: "export \\* from './period-segmentation'"
---

<objective>
Build the period segmentation engine and trend detection module for edge decay analysis.

Purpose: These are the foundational calculations for Phase 46 -- segmenting trades into yearly/quarterly/monthly periods with full metrics per period, detecting trends via linear regression, and identifying worst consecutive losing month stretches. This is consumed by the MCP tool in Plan 03 and by downstream phases (47-50).

Output: Two new calculation files (`period-segmentation.ts`, `trend-detection.ts`), barrel exports updated, and comprehensive tests.
</objective>

<execution_context>
@/Users/davidromeo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidromeo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/46-core-calculation-engines/46-CONTEXT.md
@.planning/phases/46-core-calculation-engines/46-RESEARCH.md
@packages/lib/calculations/portfolio-stats.ts
@packages/lib/calculations/kelly.ts
@packages/lib/calculations/statistical-utils.ts
@packages/lib/calculations/streak-analysis.ts
@packages/lib/calculations/performance.ts
@packages/lib/calculations/index.ts
@packages/lib/models/trade.ts
@packages/lib/models/portfolio-stats.ts
@packages/mcp-server/src/tools/reports/slippage-trends.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract trend detection and build period segmentation engine</name>
  <files>
    packages/lib/calculations/trend-detection.ts
    packages/lib/calculations/period-segmentation.ts
    packages/lib/calculations/index.ts
  </files>
  <action>
**1. Create `packages/lib/calculations/trend-detection.ts`**

Extract the OLS linear regression from `packages/mcp-server/src/tools/reports/slippage-trends.ts` (lines 226-284) into a reusable pure function. Adapt it for general use:

```typescript
import { normalCDF } from './statistical-utils'

export interface TrendResult {
  slope: number           // Raw slope (unrounded -- rounding is consumer's job)
  intercept: number
  rSquared: number        // Coefficient of determination
  pValue: number          // Two-tailed p-value via normal approximation
  stderr: number          // Standard error of the slope
  sampleSize: number      // Number of data points
}

export interface TrendAnalysis {
  [metricName: string]: TrendResult | null  // null when < 2 data points
}
```

- `linearRegression(y: number[]): TrendResult | null` -- takes an array of values (x-axis is implicit index 0,1,2...). Returns null if y.length < 2. Uses OLS exactly as in slippage-trends.ts but WITHOUT interpretation labels (no "improving/stable/degrading" -- per CONTEXT.md). Include `sampleSize` in the result.
- `computeTrends(metricSeries: Record<string, number[]>): TrendAnalysis` -- convenience function that runs linearRegression on each metric series and returns keyed results. This is what period-segmentation will call with e.g. `{ winRate: [0.6, 0.55, 0.5], profitFactor: [1.3, 1.1, 0.9], ... }`.

Use the exact same math as slippage-trends.ts: OLS slope/intercept, R-squared via 1 - SSres/SStot, MSE = SSres/(n-2), stderr = sqrt(MSE/sumX2), t-stat = slope/stderr, pValue = 2*(1-normalCDF(|t|)).

**2. Create `packages/lib/calculations/period-segmentation.ts`**

This is the main engine. Import Trade from `../models/trade`, PortfolioStatsCalculator from `./portfolio-stats`, calculateKellyMetrics from `./kelly`, computeTrends from `./trend-detection`.

Key interfaces:

```typescript
export interface PeriodMetrics {
  periodKey: string       // "2024", "2024-Q1", "2024-01"
  periodLabel: string     // "2024", "Q1 2024", "Jan 2024"
  startDate: string       // ISO date of first trade in period
  endDate: string         // ISO date of last trade in period
  tradeCount: number
  isPartial: boolean      // true if period doesn't span its full calendar range
  partialNote?: string    // e.g. "14 days of 90" for a partial quarter

  // Core metrics
  winRate: number         // decimal 0-1
  profitFactor: number
  kellyPercent: number    // from calculateKellyMetrics
  sharpeRatio: number | null  // null if insufficient data (< 5 trading days)
  avgMonthlyReturnPct: number // avg monthly return as % of equity
  netPl: number
  totalPl: number
  totalCommissions: number
}

export interface ConsecutiveLosingStretch {
  startMonth: string      // "2024-03"
  endMonth: string        // "2024-06"
  months: number          // 4
  totalLoss: number       // sum of net P&L for those months
}

export interface PeriodSegmentationResult {
  yearly: PeriodMetrics[]
  quarterly: PeriodMetrics[]
  monthly: PeriodMetrics[]

  trends: {
    yearly: TrendAnalysis   // regression on yearly metric series
    quarterly: TrendAnalysis
  }

  worstConsecutiveLosingMonths: {
    allTime: ConsecutiveLosingStretch | null
    current: ConsecutiveLosingStretch | null  // null if not currently in a losing streak
  }

  dataQuality: {
    totalTrades: number
    totalMonths: number
    sufficientForTrends: boolean  // need >= 3 periods for meaningful regression
    warnings: string[]
  }
}
```

Main export: `segmentByPeriod(trades: Trade[]): PeriodSegmentationResult`

Implementation approach:
1. Sort trades chronologically by dateOpened (use getFullYear(), getMonth() -- local time, NOT toISOString which converts to UTC per CLAUDE.md timezone rules).
2. Group trades into monthly buckets using key `YYYY-MM` derived from `trade.dateOpened.getFullYear()` and `String(trade.dateOpened.getMonth()+1).padStart(2,'0')`.
3. For each monthly bucket, compute metrics:
   - Create a `PortfolioStatsCalculator` instance and call `calculatePortfolioStats(periodTrades)` to get winRate, profitFactor, sharpeRatio, netPl, totalPl, totalCommissions, initialCapital.
   - Call `calculateKellyMetrics(periodTrades)` for kellyPercent.
   - For avgMonthlyReturnPct: this IS the single month's return. Calculate as `(netPl / initialCapital) * 100` where initialCapital comes from `PortfolioStatsCalculator.calculateInitialCapital(periodTrades)`. If initialCapital is 0 or negative, use the first trade's fundsAtClose - pl as fallback.
4. Aggregate monthly into quarterly ("YYYY-QN") and yearly ("YYYY") by grouping monthly keys.
   - For quarterly/yearly: re-run PortfolioStatsCalculator on the combined trades for that period (don't average monthly metrics -- recalculate from raw trades).
   - avgMonthlyReturnPct for quarters/years = mean of constituent monthly returns.
5. Detect partial periods:
   - Monthly: compare actual trade date range to calendar month boundaries.
   - Quarterly: compare to calendar quarter boundaries.
   - Yearly: compare to Jan 1 - Dec 31.
   - A period is partial if the first trade is after the period start OR last trade is before the period end by a significant margin. Use heuristic: if trade date range covers < 50% of the calendar period's business days, mark partial.
   - Simpler approach: mark first and last periods of the dataset as partial unconditionally, plus any period with < 5 trades.
6. Build trend analysis:
   - Extract metric arrays from yearly periods (e.g., `yearly.map(p => p.winRate)`).
   - Call `computeTrends({ winRate: [...], profitFactor: [...], kellyPercent: [...], sharpeRatio: [...], avgMonthlyReturnPct: [...], netPl: [...], tradeCount: [...] })`.
   - Same for quarterly.
   - Skip metrics where any value is null (e.g., Sharpe for periods with insufficient data).
7. Find worst consecutive losing months via `findWorstConsecutiveLosingMonths(monthlyPeriods)`.

Also export: `findWorstConsecutiveLosingMonths(monthly: PeriodMetrics[]): { allTime: ConsecutiveLosingStretch | null, current: ConsecutiveLosingStretch | null }`

This function:
- Iterates through monthly periods in chronological order.
- A "losing month" has netPl < 0.
- Track current consecutive run of losing months and all-time worst.
- For "current": if the last month in the array is part of a losing streak, that streak is the current one.
- Return both allTime worst and current (null if last month was profitable).

**3. Update `packages/lib/calculations/index.ts`**

Add two new export lines BEFORE the cumulative-distribution re-export block:
```typescript
export * from './trend-detection'
export * from './period-segmentation'
```

IMPORTANT constraints:
- NO interpretive labels anywhere. No "improving", "deteriorating", "stable". Just raw numbers (slope, R2, pValue, sampleSize).
- Use local time methods (getFullYear, getMonth) for date grouping, NOT toISOString.
- Sharpe should be null (not 0) when there's insufficient data for a period.
- For Sharpe in per-period calculation, pass `isStrategyFiltered = false` and no daily logs (we only have trades for sub-periods).
  </action>
  <verify>
Run `npm run build --workspace=packages/lib` to confirm no TypeScript errors. Verify exports are accessible: `npx ts-node -e "import { segmentByPeriod, linearRegression, computeTrends } from './packages/lib/calculations'; console.log('OK')"` (or equivalent check via build).
  </verify>
  <done>
- `trend-detection.ts` exports `linearRegression` and `computeTrends` with no interpretive labels
- `period-segmentation.ts` exports `segmentByPeriod` producing yearly/quarterly/monthly breakdowns with all 7 metrics per period, trend analysis, and worst consecutive losing month data
- `index.ts` re-exports both new modules
- All types are well-defined with JSDoc comments
- No timezone bugs (uses local time methods)
  </done>
</task>

<task type="auto">
  <name>Task 2: Test period segmentation and trend detection</name>
  <files>
    tests/unit/period-segmentation.test.ts
  </files>
  <action>
Create comprehensive tests for the period segmentation engine and trend detection. Use the existing test patterns from `tests/unit/` (import from `@tradeblocks/lib`, use Jest).

**Test structure:**

```typescript
import { segmentByPeriod, linearRegression, computeTrends, findWorstConsecutiveLosingMonths } from '@tradeblocks/lib'
import type { Trade } from '@tradeblocks/lib'
```

Create a helper function `makeTrade(overrides: Partial<Trade>): Trade` that fills in sensible defaults for all required Trade fields (dateOpened, timeOpened, pl, fundsAtClose, numContracts, marginReq, strategy, openingCommissionsFees, closingCommissionsFees, openingPrice, legs, premium, openingShortLongRatio). This keeps tests readable.

**Test cases for `linearRegression`:**
1. Returns null for empty array and single-element array
2. Perfect positive trend: [1, 2, 3, 4, 5] -- slope ~1.0, R2 ~1.0, pValue < 0.05
3. Flat data: [5, 5, 5, 5] -- slope ~0, R2 ~0
4. Two data points: [0, 10] -- returns valid result (minimum for regression)
5. Noisy data: verify slope direction and that pValue reflects noise

**Test cases for `computeTrends`:**
1. Multiple metric series: returns keyed results
2. Series with < 2 points returns null for that metric

**Test cases for `segmentByPeriod`:**
1. **Empty trades**: returns empty arrays, dataQuality shows 0 trades
2. **Single trade**: produces 1 yearly, 1 quarterly, 1 monthly period. All marked partial.
3. **Trades spanning 2 years**: produces 2 yearly periods, correct quarterly breakdowns. Verify winRate, profitFactor, netPl are reasonable.
4. **Monthly grouping correctness**: create trades across Jan, Feb, Mar of same year. Verify 3 monthly periods with correct keys ("YYYY-01", "YYYY-02", "YYYY-03").
5. **Metrics accuracy**: create 10 winning trades (pl > 0) and 5 losing trades (pl < 0) in same month. Verify winRate = 10/15, profitFactor > 1, kellyPercent > 0.
6. **Trend detection integration**: create trades spanning 4 years with declining win rates. Verify yearly trends show negative slope for winRate.
7. **Partial period detection**: first and last periods should be marked partial.

**Test cases for `findWorstConsecutiveLosingMonths`:**
1. No losing months: returns null for both allTime and current
2. Single losing month: allTime has 1-month stretch, current is null if last month is profitable
3. Multiple losing stretches: correctly identifies the worst (longest or most negative)
4. Currently active losing streak: current is non-null when last month is losing
5. All months losing: allTime spans entire range, current equals allTime

Run tests with: `npm test -- tests/unit/period-segmentation.test.ts`

Target: All tests pass. At least 15 test cases covering the key behaviors.
  </action>
  <verify>
`npm test -- tests/unit/period-segmentation.test.ts` passes with all tests green.
  </verify>
  <done>
- At least 15 test cases pass covering linearRegression, computeTrends, segmentByPeriod, and findWorstConsecutiveLosingMonths
- Edge cases tested: empty trades, single trade, partial periods, active losing streaks
- Metric accuracy verified for known inputs
  </done>
</task>

</tasks>

<verification>
1. `npm run build --workspace=packages/lib` succeeds with no errors
2. `npm test -- tests/unit/period-segmentation.test.ts` -- all tests pass
3. `npm test` -- full test suite still passes (no regressions)
4. No interpretive labels in any output (grep for "improving", "deteriorating", "stable", "degrading" in new files -- should return nothing)
</verification>

<success_criteria>
- Period segmentation engine produces yearly/quarterly/monthly breakdowns with 7+ metrics per period
- Trend detection via linear regression returns slope, R2, pValue, sampleSize with no interpretive labels
- Worst consecutive losing month stretch identified with both all-time and current tracking
- All new code is pure functions, no classes
- Tests cover at least 15 scenarios with all passing
</success_criteria>

<output>
After completion, create `.planning/phases/46-core-calculation-engines/46-01-SUMMARY.md`
</output>
