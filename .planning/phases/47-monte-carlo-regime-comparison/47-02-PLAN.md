---
phase: 47-monte-carlo-regime-comparison
plan: 02
type: execute
wave: 2
depends_on: ["47-01"]
files_modified:
  - packages/mcp-server/src/tools/edge-decay.ts
  - packages/mcp-server/package.json
autonomous: true

must_haves:
  truths:
    - "MCP tool analyze_regime_comparison is registered and callable via CLI --call mode"
    - "Tool accepts blockId (required), strategy (optional), recentWindowSize (optional), numSimulations (optional), and randomSeed (optional) via Zod-validated schema"
    - "Tool returns a text summary with P(Profit), Sharpe, and divergence severity plus structured JSON with full comparison data"
    - "Tool returns clear error message when block has insufficient trades"
  artifacts:
    - path: "packages/mcp-server/src/tools/edge-decay.ts"
      provides: "analyze_regime_comparison MCP tool alongside existing edge decay tools"
      exports: ["registerEdgeDecayTools"]
    - path: "packages/mcp-server/package.json"
      provides: "Version bump for new MCP tool"
  key_links:
    - from: "packages/mcp-server/src/tools/edge-decay.ts"
      to: "packages/lib/calculations/mc-regime-comparison.ts"
      via: "runRegimeComparison for dual MC simulation"
      pattern: "runRegimeComparison"
    - from: "packages/mcp-server/src/tools/edge-decay.ts"
      to: "packages/mcp-server/src/utils/output-formatter.ts"
      via: "createToolOutput for JSON-first response"
      pattern: "createToolOutput"
---

<objective>
Register the `analyze_regime_comparison` MCP tool in the edge-decay tools module and verify it works via CLI.

Purpose: Expose the MC regime comparison engine to Claude via MCP, completing the Phase 47 deliverable. This tool will be consumed by Phase 50's unified edge decay verdict tool.

Output: Updated `edge-decay.ts` with a third registered tool, version bump in package.json, and CLI verification.
</objective>

<execution_context>
@/Users/davidromeo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidromeo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/47-monte-carlo-regime-comparison/47-RESEARCH.md
@.planning/phases/47-monte-carlo-regime-comparison/47-01-SUMMARY.md
@packages/mcp-server/src/tools/edge-decay.ts
@packages/mcp-server/src/utils/output-formatter.ts
@packages/mcp-server/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register analyze_regime_comparison MCP tool</name>
  <files>
    packages/mcp-server/src/tools/edge-decay.ts
    packages/mcp-server/package.json
  </files>
  <action>
**1. Add import for `runRegimeComparison` in `edge-decay.ts`**

Update the existing import from `@tradeblocks/lib` to include `runRegimeComparison`:

```typescript
import {
  segmentByPeriod,
  computeRollingMetrics,
  runRegimeComparison,
} from "@tradeblocks/lib";
```

**2. Register the tool inside `registerEdgeDecayTools` function**

After the existing `analyze_rolling_metrics` tool registration (around line 237), add a third tool:

```typescript
// Tool 3: analyze_regime_comparison
server.registerTool(
  "analyze_regime_comparison",
  {
    description:
      "Run dual Monte Carlo simulations comparing full trade history vs recent window to detect regime divergence. Compares P(Profit), expected return, Sharpe ratio, and median max drawdown between the two periods. Classifies divergence severity as aligned, mild_divergence, significant_divergence, or regime_break.",
    inputSchema: z.object({
      blockId: z.string().describe("Block folder name"),
      strategy: z.string().optional().describe("Filter by strategy name (case-insensitive)"),
      recentWindowSize: z.number().min(20).optional().describe("Number of recent trades for the recent window simulation (default: auto-calculated, typically max(20% of trades, 200))"),
      numSimulations: z.number().min(50).max(10000).optional().describe("Number of Monte Carlo simulation paths (default: 1000)"),
      simulationLength: z.number().min(10).optional().describe("Number of trades to project forward per simulation (default: recentWindowSize)"),
      randomSeed: z.number().optional().describe("Random seed for reproducibility (default: 42)"),
    }),
  },
  withSyncedBlock(baseDir, async ({ blockId, strategy, recentWindowSize, numSimulations, simulationLength, randomSeed }) => {
    try {
      const block = await loadBlock(baseDir, blockId);
      let trades = block.trades;

      // Apply strategy filter
      trades = filterByStrategy(trades, strategy);

      if (trades.length === 0) {
        return {
          content: [{ type: "text" as const, text: strategy
            ? `No trades found for strategy "${strategy}" in block "${blockId}".`
            : `No trades found in block "${blockId}".` }],
          isError: true as const,
        };
      }

      const result = runRegimeComparison(trades, {
        recentWindowSize,
        numSimulations,
        simulationLength,
        randomSeed,
        strategy: undefined,  // Already filtered above
      });

      // Build summary
      const fullPProfit = (result.fullHistory.statistics.probabilityOfProfit * 100).toFixed(1);
      const recentPProfit = (result.recentWindow.statistics.probabilityOfProfit * 100).toFixed(1);
      const fullSharpe = result.fullHistory.statistics.meanSharpeRatio.toFixed(2);
      const recentSharpe = result.recentWindow.statistics.meanSharpeRatio.toFixed(2);
      const severity = result.divergence.severity.replace(/_/g, ' ');
      const score = result.divergence.compositeScore.toFixed(2);

      const summary = `Regime comparison for ${blockId}${strategy ? ` (${strategy})` : ""}: ${result.fullHistory.tradeCount} full / ${result.recentWindow.tradeCount} recent trades\nP(Profit): ${fullPProfit}% (full) vs ${recentPProfit}% (recent) | Sharpe: ${fullSharpe} (full) vs ${recentSharpe} (recent)\nDivergence: ${severity} (score: ${score})`;

      const structuredData = {
        blockId,
        strategy: strategy ?? null,
        fullHistory: {
          tradeCount: result.fullHistory.tradeCount,
          dateRange: result.fullHistory.dateRange,
          statistics: {
            probabilityOfProfit: result.fullHistory.statistics.probabilityOfProfit,
            meanTotalReturn: result.fullHistory.statistics.meanTotalReturn,
            meanSharpeRatio: result.fullHistory.statistics.meanSharpeRatio,
            medianMaxDrawdown: result.fullHistory.statistics.medianMaxDrawdown,
            meanFinalValue: result.fullHistory.statistics.meanFinalValue,
            medianFinalValue: result.fullHistory.statistics.medianFinalValue,
          },
        },
        recentWindow: {
          tradeCount: result.recentWindow.tradeCount,
          dateRange: result.recentWindow.dateRange,
          statistics: {
            probabilityOfProfit: result.recentWindow.statistics.probabilityOfProfit,
            meanTotalReturn: result.recentWindow.statistics.meanTotalReturn,
            meanSharpeRatio: result.recentWindow.statistics.meanSharpeRatio,
            medianMaxDrawdown: result.recentWindow.statistics.medianMaxDrawdown,
            meanFinalValue: result.recentWindow.statistics.meanFinalValue,
            medianFinalValue: result.recentWindow.statistics.medianFinalValue,
          },
        },
        comparison: result.comparison,
        divergence: result.divergence,
        parameters: result.parameters,
      };

      return createToolOutput(summary, structuredData);
    } catch (error) {
      return {
        content: [{ type: "text" as const, text: `Error analyzing regime comparison: ${(error as Error).message}` }],
        isError: true as const,
      };
    }
  })
);
```

**3. Bump MCP server version in `packages/mcp-server/package.json`**

Bump from `0.7.0` to `0.7.1` (minor feature addition within the edge decay milestone).

**IMPORTANT constraints:**
- Reuse the existing `filterByStrategy` helper already in edge-decay.ts.
- Use `withSyncedBlock` wrapper for auto-sync before execution.
- In the structured output, only include the 6 most relevant statistics fields (not the full SimulationStatistics with VaR etc.) to keep output size manageable.
- Strategy filtering is done BEFORE calling `runRegimeComparison` so pass `strategy: undefined` in options to avoid double-filtering.
  </action>
  <verify>
1. Build the MCP server: `npm run build --workspace=packages/mcp-server`
2. Verify the tool is registered by running: `TRADEBLOCKS_DATA_DIR=~/backtests tradeblocks-mcp --list-tools | grep regime`
3. Test with a real block: `TRADEBLOCKS_DATA_DIR=~/backtests tradeblocks-mcp --call analyze_regime_comparison '{"blockId":"main-port-2026"}'`
  </verify>
  <done>
- analyze_regime_comparison tool is registered in the MCP server
- Tool accepts blockId, strategy, recentWindowSize, numSimulations, simulationLength, randomSeed via Zod schema
- Tool returns text summary with P(Profit), Sharpe, divergence severity AND structured JSON with full comparison data
- MCP server version bumped to 0.7.1
- CLI --call mode works with a real block
  </done>
</task>

</tasks>

<verification>
1. `npm run build --workspace=packages/mcp-server` succeeds
2. `npm test` -- full test suite passes (no regressions)
3. `TRADEBLOCKS_DATA_DIR=~/backtests tradeblocks-mcp --call analyze_regime_comparison '{"blockId":"main-port-2026"}'` returns valid output with divergence classification
4. Tool appears in `--list-tools` output
</verification>

<success_criteria>
- analyze_regime_comparison MCP tool is callable and returns structured comparison data
- Divergence severity is one of: aligned, mild_divergence, significant_divergence, regime_break
- Tool handles insufficient trades gracefully with error message
- MCP server builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/47-monte-carlo-regime-comparison/47-02-SUMMARY.md`
</output>
