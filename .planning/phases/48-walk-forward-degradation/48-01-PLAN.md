---
phase: 48-walk-forward-degradation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/lib/calculations/walk-forward-degradation.ts
  - packages/lib/calculations/index.ts
  - tests/unit/walk-forward-degradation.test.ts
autonomous: true

must_haves:
  truths:
    - "Progressive walk-forward windows slide across trade history with configurable IS/OOS/step days"
    - "Each period computes IS and OOS metrics (Sharpe, win rate, profit factor) via PortfolioStatsCalculator"
    - "OOS efficiency ratios (OOS/IS) are computed with division-by-near-zero safety"
    - "Linear regression trend detection runs on efficiency time series"
    - "Recent vs historical OOS average comparison is computed with deltas"
    - "Periods with insufficient trades are flagged with warnings, not errors"
  artifacts:
    - path: "packages/lib/calculations/walk-forward-degradation.ts"
      provides: "WFD engine with analyzeWalkForwardDegradation function"
      exports: ["analyzeWalkForwardDegradation", "WFDConfig", "WFDResult", "WFDPeriodResult", "WFDWindow"]
    - path: "tests/unit/walk-forward-degradation.test.ts"
      provides: "Comprehensive tests for WFD engine"
      min_lines: 150
    - path: "packages/lib/calculations/index.ts"
      provides: "Re-exports WFD module"
      contains: "walk-forward-degradation"
  key_links:
    - from: "walk-forward-degradation.ts"
      to: "portfolio-stats.ts"
      via: "PortfolioStatsCalculator.calculatePortfolioStats for IS/OOS Sharpe"
      pattern: "calculatePortfolioStats"
    - from: "walk-forward-degradation.ts"
      to: "trend-detection.ts"
      via: "computeTrends for efficiency time series trends"
      pattern: "computeTrends"
    - from: "walk-forward-degradation.ts"
      to: "kelly.ts"
      via: "calculateKellyMetrics for per-window profit factor"
      pattern: "calculateKellyMetrics"
---

<objective>
Build the Walk-Forward Degradation (WFD) calculation engine that measures how out-of-sample performance evolves relative to in-sample performance across progressive time windows.

Purpose: WFD provides a unique signal distinct from rolling/period metrics -- it answers "did performance in the preceding training period predict performance in the subsequent test period?" by pairing IS/OOS windows and tracking efficiency ratios over time.

Output: `walk-forward-degradation.ts` with `analyzeWalkForwardDegradation()` function, comprehensive test suite, and index.ts re-export.
</objective>

<execution_context>
@/Users/davidromeo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidromeo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/48-walk-forward-degradation/48-RESEARCH.md
@.planning/phases/48-walk-forward-degradation/48-CONTEXT.md

Key reference files (read before implementing):
@packages/lib/calculations/mc-regime-comparison.ts (pattern for sortTradesChronologically, formatLocalDate, strategy filtering, structure)
@packages/lib/calculations/rolling-metrics.ts (pattern for sortTradesChronologically, formatLocalDate, calculateDefaultRecentWindow, computeWindowMetrics)
@packages/lib/calculations/period-segmentation.ts (pattern for PortfolioStatsCalculator usage, toLocalISODate, PeriodMetrics)
@packages/lib/calculations/trend-detection.ts (computeTrends, linearRegression, TrendResult, TrendAnalysis)
@packages/lib/calculations/portfolio-stats.ts (calculatePortfolioStats returns PortfolioStats with sharpeRatio, winRate, profitFactor)
@packages/lib/calculations/kelly.ts (calculateKellyMetrics)
@packages/lib/calculations/index.ts (add re-export)
@tests/unit/mc-regime-comparison.test.ts (test pattern: makeTrade, generateTradeSet helpers)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create walk-forward-degradation.ts calculation engine</name>
  <files>packages/lib/calculations/walk-forward-degradation.ts, packages/lib/calculations/index.ts</files>
  <action>
Create `packages/lib/calculations/walk-forward-degradation.ts` (~200-250 lines) following the established edge decay calculation pattern.

**Module header:** Same JSDoc style as mc-regime-comparison.ts and rolling-metrics.ts. State it's consumed by MCP tool in Plan 02 and by verdict synthesis in Phase 50. "All outputs are factual, numerical data -- no interpretive labels."

**Imports:**
- `Trade` from `../models/trade`
- `PortfolioStatsCalculator` from `./portfolio-stats`
- `calculateKellyMetrics` from `./kelly`
- `computeTrends, type TrendResult` from `./trend-detection`

**Interfaces (all exported):**

`WFDConfig`:
- `inSampleDays`: number (default 365)
- `outOfSampleDays`: number (default 90)
- `stepSizeDays`: number (default 90)
- `minTradesPerPeriod`: number (default 10)
- `recentPeriodCount`: number (default 3) -- how many recent WF periods for recent-vs-historical comparison
- `strategy?`: string -- optional case-insensitive strategy filter

`WFDWindow`:
- `periodIndex`: number
- `inSampleStart`: string (YYYY-MM-DD)
- `inSampleEnd`: string
- `outOfSampleStart`: string
- `outOfSampleEnd`: string
- `inSampleTradeCount`: number
- `outOfSampleTradeCount`: number

`WFDMetricSet`:
- `sharpe`: number | null
- `winRate`: number
- `profitFactor`: number

`WFDPeriodResult`:
- `window`: WFDWindow
- `metrics`: object with three keys (sharpe, winRate, profitFactor), each having `{ inSample: number | null, outOfSample: number | null, efficiency: number | null }`
- `sufficient`: boolean (both IS and OOS meet minTradesPerPeriod)
- `warnings`: string[]

`WFDResult`:
- `periods`: WFDPeriodResult[]
- `efficiencyTrends`: object with keys sharpe, winRate, profitFactor, each TrendResult | null
- `recentVsHistorical`: object with `recentPeriodCount`, `recentAvgEfficiency` (WFDMetricSet with nulls), `historicalAvgEfficiency` (same), `delta` (same)
- `config`: WFDConfig (resolved)
- `dataQuality`: object with `totalTrades`, `totalPeriods`, `sufficientPeriods`, `skippedPeriods`, `sufficientForTrends` (boolean, requires >= 4 sufficient periods), `warnings` (string[])

**Private helpers:**

1. `sortTradesChronologically(trades)` -- copy from rolling-metrics.ts pattern (sort by local date components then timeOpened)

2. `formatLocalDate(date)` -- copy from rolling-metrics.ts pattern (getFullYear, getMonth+1, getDate with zero-pad)

3. `floorToLocalDate(date)` -- returns new Date with same local year/month/day but time zeroed: `new Date(date.getFullYear(), date.getMonth(), date.getDate())`

4. `buildDegradationWindows(firstTradeDate, lastTradeDate, config)` -- builds sliding windows:
   - Use DAY_MS = 86400000
   - Start cursor at floorToLocalDate(firstTradeDate)
   - Loop: create IS window [cursor, cursor + IS_days - 1], OOS window [IS_end + 1 day, IS_end + OOS_days]
   - Break if OOS start > lastTradeDate (no OOS trades possible)
   - Step cursor by stepSizeDays * DAY_MS
   - Return WFDWindow[] (trade counts initially 0, filled later)

5. `filterTradesForWindow(sortedTrades, startDate, endDate)` -- returns trades whose dateOpened falls within [startDate, endDate] inclusive, using formatLocalDate comparison

6. `computeMetrics(trades)` -- compute Sharpe, winRate, profitFactor for a window:
   - Use `new PortfolioStatsCalculator().calculatePortfolioStats(trades)` to get sharpeRatio
   - Compute winRate manually (wins / total) -- same pattern as rolling-metrics computeWindowMetrics
   - Compute profitFactor manually (gross wins / |gross losses|) -- same pattern
   - Return WFDMetricSet

7. `computeEfficiency(oosValue, isValue, metric)` -- returns number | null:
   - Return null if either is null or not finite
   - EPSILON: { sharpe: 0.01, profitFactor: 0.01, winRate: 0 }
   - Return null if |isValue| < epsilon (near-zero IS)
   - Handle Infinity profitFactor: return null
   - Otherwise return oosValue / isValue

**Main exported function: `analyzeWalkForwardDegradation(trades, options?)`**

1. Apply strategy filter (case-insensitive) if provided
2. Sort trades chronologically
3. Validate: if fewer than 2 trades, return empty result with warning
4. Build windows from first/last trade dates
5. If 0 windows produced, return empty result with "Insufficient trade history" warning
6. For each window:
   - Filter IS trades and OOS trades
   - Set trade counts on window
   - Check sufficiency (both >= minTradesPerPeriod)
   - If insufficient: mark sufficient=false, add warning, set metrics to null where applicable
   - If sufficient: compute IS metrics, OOS metrics, and efficiency ratios
   - Add warning if IS Sharpe is negative ("Negative IS Sharpe in period N -- efficiency ratio may be misleading")
7. Compute efficiency trends via computeTrends on sufficient periods' efficiency values (filter nulls)
8. Compute recent vs historical:
   - Take last N sufficient periods as "recent" (N = config.recentPeriodCount)
   - Remaining sufficient periods as "historical"
   - Average each efficiency metric separately (handle nulls by excluding)
   - Delta = recent - historical (null if either side null)
9. Build dataQuality: totalTrades, totalPeriods, sufficientPeriods, skippedPeriods, sufficientForTrends (>= 4 sufficient), warnings (top-level)
10. Return WFDResult with resolved config

**Add re-export to index.ts:**
Add `export * from './walk-forward-degradation'` after the mc-regime-comparison line in `packages/lib/calculations/index.ts`.
  </action>
  <verify>
Run `npx tsc --noEmit --project packages/lib/tsconfig.json 2>&1 | head -20` to verify no TypeScript errors. If lib doesn't have its own tsconfig, use `npm run typecheck` or the project root tsconfig.
  </verify>
  <done>
walk-forward-degradation.ts exists with analyzeWalkForwardDegradation exported, all interfaces exported, index.ts re-exports the module, and TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive test suite for WFD engine</name>
  <files>tests/unit/walk-forward-degradation.test.ts</files>
  <action>
Create `tests/unit/walk-forward-degradation.test.ts` following the mc-regime-comparison.test.ts pattern.

**Test helpers (same pattern as mc-regime-comparison.test.ts):**

```typescript
function makeTrade(overrides: Partial<Trade> = {}): Trade {
  return {
    dateOpened: new Date('2024-01-15'),
    timeOpened: '09:30:00',
    openingPrice: 100,
    legs: 'SPX Put Spread',
    premium: 1.5,
    pl: 100,
    numContracts: 1,
    fundsAtClose: 100100,
    marginReq: 5000,
    strategy: 'Iron Condor',
    openingCommissionsFees: 1.5,
    closingCommissionsFees: 1.5,
    openingShortLongRatio: 1.0,
    ...overrides,
  }
}

function generateTradeSet(count, options?) // Same as mc-regime-comparison.test.ts
```

**Generate trades spanning enough time for multiple WF windows:**
For default config (365d IS + 90d OOS + 90d step), need at least ~500-600 days of trades.
Use a helper that generates trades across 2+ years, e.g., generateTradeSet(500, { startDate: new Date(2022, 0, 1) }).

**Test groups:**

**describe('analyzeWalkForwardDegradation'):**
1. "returns empty result with warning for fewer than 2 trades" -- pass 1 trade, check periods=[], warnings include "insufficient"
2. "returns empty result when history too short for any window" -- pass trades spanning only 30 days with default 365d IS, check 0 periods
3. "produces correct number of windows for 2-year history" -- 730 days, IS=365, OOS=90, step=90 should produce specific window count. Verify periodIndex, IS/OOS date ranges
4. "respects custom config (IS=180, OOS=60, step=60)" -- shorter windows produce more periods
5. "computes IS and OOS metrics for each period" -- check that each sufficient period has non-null metrics for winRate and profitFactor, and sharpe is number or null
6. "computes efficiency ratios correctly" -- for a period with known IS and OOS values, verify efficiency = OOS/IS
7. "handles strategy filter (case-insensitive)" -- mix strategies, filter to one, verify only matching trades appear
8. "marks periods with insufficient trades as not sufficient" -- set minTradesPerPeriod=50, verify some periods get sufficient=false
9. "adds warning for negative IS Sharpe" -- generate losing trades in IS window, check for warning string
10. "returns null efficiency for near-zero IS metrics" -- verify that when IS Sharpe ~ 0, efficiency is null

**describe('efficiency trends'):**
11. "computes linear regression trends on efficiency series" -- check efficiencyTrends has sharpe/winRate/profitFactor keys, each TrendResult or null
12. "sets sufficientForTrends=false with fewer than 4 sufficient periods" -- only 3 periods, check flag

**describe('recent vs historical comparison'):**
13. "computes recent vs historical averages" -- verify recentAvgEfficiency, historicalAvgEfficiency, delta
14. "uses last N sufficient periods for recent" -- set recentPeriodCount=2, verify only last 2 sufficient periods are "recent"
15. "handles case where all periods are recent" -- if recentPeriodCount >= total sufficient periods, historical should have null averages

**describe('edge cases'):**
16. "handles all-winning trades" -- profitFactor=Infinity in some periods, efficiency null for PF
17. "handles all-losing trades" -- winRate=0, profitFactor=0
18. "config defaults are sensible" -- call with no options, verify config in result has expected defaults

Run with: `npm test -- tests/unit/walk-forward-degradation.test.ts`

Ensure ALL tests pass. Fix any failures in the engine code before completing.
  </action>
  <verify>
Run `npm test -- tests/unit/walk-forward-degradation.test.ts` -- all tests must pass.
Then run `npm test` to verify no regressions across the full suite.
  </verify>
  <done>
18+ tests pass for WFD engine covering: window building, metric computation, efficiency ratios, trend detection, recent-vs-historical comparison, and edge cases. Full test suite has zero regressions.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with no errors related to walk-forward-degradation
2. `npm test -- tests/unit/walk-forward-degradation.test.ts` -- all tests pass
3. `npm test` -- full suite passes with no regressions
4. `analyzeWalkForwardDegradation` is exported from `@tradeblocks/lib`
5. No interpretive labels in calculation code (no "good", "bad", "concerning", etc.)
</verification>

<success_criteria>
- walk-forward-degradation.ts exists with ~200-250 lines
- analyzeWalkForwardDegradation accepts trades + optional config, returns WFDResult
- Progressive windows slide correctly across trade history
- IS and OOS metrics (Sharpe, winRate, profitFactor) computed per period
- Efficiency ratios computed with division-by-near-zero safety
- Linear regression trends computed on efficiency series via computeTrends
- Recent vs historical comparison computed with configurable period count
- 18+ tests pass covering all scenarios
- Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/48-walk-forward-degradation/48-01-SUMMARY.md`
</output>
