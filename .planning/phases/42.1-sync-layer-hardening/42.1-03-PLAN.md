---
phase: 42.1-sync-layer-hardening
plan: 03
type: execute
wave: 2
depends_on: ["42.1-02"]
files_modified:
  - packages/mcp-server/src/tools/middleware/sync-middleware.ts
  - packages/mcp-server/src/tools/blocks/core.ts
  - packages/mcp-server/src/tools/blocks/comparison.ts
  - packages/mcp-server/src/tools/blocks/analysis.ts
  - packages/mcp-server/src/tools/blocks/similarity.ts
  - packages/mcp-server/src/tools/blocks/health.ts
  - packages/mcp-server/src/tools/reports/fields.ts
  - packages/mcp-server/src/tools/reports/queries.ts
  - packages/mcp-server/src/tools/reports/predictive.ts
  - packages/mcp-server/src/tools/reports/slippage.ts
autonomous: true

must_haves:
  truths:
    - "Sync middleware wraps tool handlers with automatic sync-before-query behavior"
    - "withSyncedBlock handles single-block tools automatically"
    - "withSyncedBlocks handles multi-block comparison tools automatically"
    - "All sync-integrated tools use the middleware pattern (no inline sync calls)"
    - "Deleted block errors are handled consistently via middleware"
  artifacts:
    - path: "packages/mcp-server/src/tools/middleware/sync-middleware.ts"
      provides: "withSyncedBlock, withSyncedBlocks middleware functions"
      exports: ["withSyncedBlock", "withSyncedBlocks", "withFullSync"]
      min_lines: 80
  key_links:
    - from: "packages/mcp-server/src/tools/blocks/core.ts"
      to: "packages/mcp-server/src/tools/middleware/sync-middleware.ts"
      via: "import { withSyncedBlock, withFullSync }"
      pattern: "withSyncedBlock|withFullSync"
    - from: "packages/mcp-server/src/tools/blocks/comparison.ts"
      to: "packages/mcp-server/src/tools/middleware/sync-middleware.ts"
      via: "import { withSyncedBlocks }"
      pattern: "withSyncedBlocks"
---

<objective>
Create sync middleware that wraps tool handlers with automatic sync-before-query behavior, eliminating ~15 lines of boilerplate per tool.

Purpose: Success criteria 5 and 6 require a middleware pattern that all sync-integrated tools use. This reduces code duplication and ensures consistent error handling for deleted blocks.

Output: `middleware/sync-middleware.ts` with middleware functions, all tool handlers updated to use them.
</objective>

<execution_context>
@/Users/davidromeo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidromeo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/42.1-sync-layer-hardening/42.1-RESEARCH.md

# Sync layer API
@packages/mcp-server/src/sync/index.ts

# Split tool files (from Plan 02)
@packages/mcp-server/src/tools/blocks/core.ts
@packages/mcp-server/src/tools/blocks/comparison.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sync middleware module</name>
  <files>
    packages/mcp-server/src/tools/middleware/sync-middleware.ts
  </files>
  <action>
Create `packages/mcp-server/src/tools/middleware/sync-middleware.ts`:

```typescript
/**
 * Sync Middleware
 *
 * Higher-order functions that wrap MCP tool handlers with automatic
 * sync-before-query behavior. Eliminates sync boilerplate from tools.
 */

import { syncBlock, syncAllBlocks, syncMarketData, type BlockSyncResult, type SyncResult, type MarketSyncResult } from "../../sync/index.js";

// MCP tool response types
interface ToolError {
  content: Array<{ type: "text"; text: string }>;
  isError: true;
}

export interface SingleBlockContext {
  syncResult: BlockSyncResult;
  baseDir: string;
}

export interface MultiBlockContext {
  syncResults: Map<string, BlockSyncResult>;
  baseDir: string;
}

export interface FullSyncContext {
  blockSyncResult: SyncResult;
  marketSyncResult: MarketSyncResult;
  baseDir: string;
}

/**
 * Middleware for tools that operate on a single block.
 * Syncs the block before calling the handler.
 * Returns error response if block was deleted.
 */
export function withSyncedBlock<TInput extends { blockId: string }, TOutput>(
  baseDir: string,
  handler: (input: TInput, ctx: SingleBlockContext) => Promise<TOutput>
): (input: TInput) => Promise<TOutput | ToolError> {
  return async (input: TInput) => {
    const syncResult = await syncBlock(input.blockId, baseDir);

    if (syncResult.status === "deleted") {
      return {
        content: [
          {
            type: "text" as const,
            text: `Block '${input.blockId}' no longer exists (folder was deleted)`,
          },
        ],
        isError: true as const,
      };
    }

    if (syncResult.status === "error" && syncResult.error) {
      return {
        content: [
          {
            type: "text" as const,
            text: `Sync error for block '${input.blockId}': ${syncResult.error}`,
          },
        ],
        isError: true as const,
      };
    }

    return handler(input, { syncResult, baseDir });
  };
}

/**
 * Middleware for tools that compare multiple blocks.
 * Syncs all specified blocks before calling the handler.
 * Returns error response if any block was deleted.
 */
export function withSyncedBlocks<
  TInput extends { blockIds?: string[]; blockIdA?: string; blockIdB?: string },
  TOutput
>(
  baseDir: string,
  handler: (input: TInput, ctx: MultiBlockContext) => Promise<TOutput>
): (input: TInput) => Promise<TOutput | ToolError> {
  return async (input: TInput) => {
    // Collect block IDs from various input patterns
    const blockIds: string[] = input.blockIds ??
      [input.blockIdA, input.blockIdB].filter((id): id is string => !!id);

    const syncResults = new Map<string, BlockSyncResult>();

    for (const blockId of blockIds) {
      const result = await syncBlock(blockId, baseDir);
      syncResults.set(blockId, result);

      if (result.status === "deleted") {
        return {
          content: [
            {
              type: "text" as const,
              text: `Block '${blockId}' no longer exists (folder was deleted)`,
            },
          ],
          isError: true as const,
        };
      }

      if (result.status === "error" && result.error) {
        return {
          content: [
            {
              type: "text" as const,
              text: `Sync error for block '${blockId}': ${result.error}`,
            },
          ],
          isError: true as const,
        };
      }
    }

    return handler(input, { syncResults, baseDir });
  };
}

/**
 * Middleware for tools that need a full sync of all blocks and market data.
 * Used by list_blocks which needs to see all available blocks.
 */
export function withFullSync<TInput, TOutput>(
  baseDir: string,
  handler: (input: TInput, ctx: FullSyncContext) => Promise<TOutput>
): (input: TInput) => Promise<TOutput> {
  return async (input: TInput) => {
    const blockSyncResult = await syncAllBlocks(baseDir);
    const marketSyncResult = await syncMarketData(baseDir);

    return handler(input, { blockSyncResult, marketSyncResult, baseDir });
  };
}
```

This middleware provides three patterns:
- `withSyncedBlock`: For single-block tools (get_statistics, stress_test, etc.)
- `withSyncedBlocks`: For multi-block tools (compare_blocks, block_diff, etc.)
- `withFullSync`: For list_blocks which needs all blocks synced
  </action>
  <verify>
Run:
```bash
cd packages/mcp-server
npm run build
```
Build succeeds with no type errors.
  </verify>
  <done>
- `middleware/sync-middleware.ts` created
- Exports `withSyncedBlock`, `withSyncedBlocks`, `withFullSync`
- Proper TypeScript types for contexts
- Consistent error handling for deleted/error states
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply middleware to blocks/* tools</name>
  <files>
    packages/mcp-server/src/tools/blocks/core.ts
    packages/mcp-server/src/tools/blocks/comparison.ts
    packages/mcp-server/src/tools/blocks/analysis.ts
    packages/mcp-server/src/tools/blocks/similarity.ts
    packages/mcp-server/src/tools/blocks/health.ts
  </files>
  <action>
Update each blocks/* tool file to use the middleware pattern:

**blocks/core.ts:**
- Import: `import { withSyncedBlock, withFullSync } from "../middleware/sync-middleware.js";`
- `list_blocks`: Wrap handler with `withFullSync(baseDir, async (input, { blockSyncResult, marketSyncResult }) => { ... })`
  - Remove inline `syncAllBlocks()` and `syncMarketData()` calls
- `get_block_info`: Wrap with `withSyncedBlock(baseDir, async ({ blockId }, { syncResult }) => { ... })`
  - Remove inline `syncBlock()` call
- `get_statistics`: Wrap with `withSyncedBlock`
- `get_reporting_log_stats`: Wrap with `withSyncedBlock`

**blocks/comparison.ts:**
- Import: `import { withSyncedBlocks } from "../middleware/sync-middleware.js";`
- `get_strategy_comparison`: Wrap with `withSyncedBlock` (single block input)
- `compare_blocks`: Wrap with `withSyncedBlocks(baseDir, async ({ blockIds, ... }, { syncResults }) => { ... })`
  - Remove inline sync calls for each block
- `block_diff`: Wrap with `withSyncedBlocks` (blockIdA, blockIdB pattern)

**blocks/analysis.ts:**
- Import middleware
- `stress_test`: Wrap with `withSyncedBlock`
- `drawdown_attribution`: Wrap with `withSyncedBlock`
- `marginal_contribution`: Wrap with `withSyncedBlocks` (needs multiple blocks)

**blocks/similarity.ts:**
- `strategy_similarity`: Wrap with `withSyncedBlocks`
- `what_if_scaling`: Wrap with `withSyncedBlock`

**blocks/health.ts:**
- `portfolio_health_check`: Wrap with `withSyncedBlock`

**Transformation pattern:**
Before:
```typescript
async ({ blockId, ... }) => {
  try {
    await syncBlock(blockId, baseDir);
    const block = await loadBlock(baseDir, blockId);
    // ... business logic
  } catch (error) {
    return { content: [...], isError: true };
  }
}
```

After:
```typescript
withSyncedBlock(baseDir, async ({ blockId, ... }, { syncResult }) => {
  try {
    const block = await loadBlock(baseDir, blockId);
    // ... business logic (sync already done, deleted already handled)
  } catch (error) {
    return { content: [...], isError: true };
  }
})
```

**Important:** Remove the explicit sync calls AND the "block deleted" error handling from each tool - the middleware handles both.
  </action>
  <verify>
Run:
```bash
cd packages/mcp-server
npm run build
npm test -- tests/integration/
```
Build passes. All integration tests pass.
  </verify>
  <done>
- All blocks/* tools use middleware pattern
- No inline `syncBlock()` or `syncAllBlocks()` calls remain in tool handlers
- Deleted block handling removed from individual tools (middleware handles it)
- All integration tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Apply middleware to reports/* tools and verify</name>
  <files>
    packages/mcp-server/src/tools/reports/fields.ts
    packages/mcp-server/src/tools/reports/queries.ts
    packages/mcp-server/src/tools/reports/predictive.ts
    packages/mcp-server/src/tools/reports/slippage.ts
  </files>
  <action>
Update each reports/* tool file to use the middleware pattern:

**First, check current state of reports tools:**
The reports.ts tools may not have sync integration yet. If they don't call syncBlock currently, add sync via middleware for consistency.

**reports/fields.ts:**
- `list_available_fields`: If it loads block data, wrap with `withSyncedBlock`
- `get_field_statistics`: Wrap with `withSyncedBlock`

**reports/queries.ts:**
- `run_filtered_query`: Wrap with `withSyncedBlock`
- `aggregate_by_field`: Wrap with `withSyncedBlock`

**reports/predictive.ts:**
- `find_predictive_fields`: Wrap with `withSyncedBlock`
- `filter_curve`: Wrap with `withSyncedBlock`

**reports/slippage.ts:**
- `analyze_discrepancies`: Wrap with `withSyncedBlock` (loads reporting log)
- `suggest_strategy_matches`: Wrap with `withSyncedBlock`
- `slippage_trends`: Wrap with `withSyncedBlock`

**Final verification:**
1. Grep for any remaining inline `syncBlock(` or `syncAllBlocks(` calls in tool files (should be zero outside middleware)
2. Run full test suite
3. Verify build passes

**Pattern check command:**
```bash
grep -r "syncBlock\|syncAllBlocks" packages/mcp-server/src/tools/ --include="*.ts" | grep -v middleware | grep -v "\.js"
```
Should return only import statements, no function calls.
  </action>
  <verify>
Run:
```bash
cd packages/mcp-server

# Check no inline sync calls remain
grep -r "await syncBlock\|await syncAllBlocks" src/tools/ --include="*.ts" | grep -v middleware || echo "No inline sync calls found (good)"

# Full build and test
npm run build
npm test
```
No inline sync calls. Build passes. All tests pass.
  </verify>
  <done>
- All reports/* tools use middleware pattern
- No inline sync calls remain in any tool file (only in middleware)
- Full test suite passes
- Grep verification confirms middleware pattern adoption
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/davidromeo/Code/tradeblocks/packages/mcp-server

# Verify middleware exists
ls -la src/tools/middleware/

# Verify no inline sync calls in tool files
grep -rn "await syncBlock\|await syncAllBlocks" src/tools/ --include="*.ts" | grep -v middleware

# Full verification
npm run build
npm run typecheck
npm test
```

Middleware file exists. No inline sync calls outside middleware. Build and all tests pass.
</verification>

<success_criteria>
1. `middleware/sync-middleware.ts` exists with withSyncedBlock, withSyncedBlocks, withFullSync
2. All 14 blocks/* tools use middleware (no inline sync calls)
3. All 9 reports/* tools use middleware (no inline sync calls)
4. `npm run build` succeeds
5. `npm test` passes all tests
6. Grep confirms no inline `await syncBlock` or `await syncAllBlocks` calls in tool files
</success_criteria>

<output>
After completion, create `.planning/phases/42.1-sync-layer-hardening/42.1-03-SUMMARY.md`
</output>
