# Phase 42.1: Sync Layer Hardening - Research

**Researched:** 2026-02-01
**Domain:** MCP Server Architecture, Testing, File Organization
**Confidence:** HIGH

## Summary

Phase 42.1 is a technical debt phase focused on three areas: (1) adding integration tests for the sync layer to verify change detection and transaction rollback, (2) splitting oversized tool files (blocks.ts at 3,374 lines, reports.ts at 3,338 lines) into manageable modules under 800 lines, and (3) implementing a middleware pattern to eliminate repetitive sync boilerplate from tool handlers.

The sync layer implementation is clean and well-structured (5 files totaling 1,243 lines). The main challenge is the tool files which contain 14 tools in blocks.ts and 9 tools in reports.ts, each with embedded sync calls. The middleware pattern will wrap tool handlers with automatic sync-before-query behavior.

**Primary recommendation:** Split tool files by functional domain (core, comparison, analysis), create a `withSyncedBlock` middleware, and add focused integration tests using temporary filesystem fixtures.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Jest | ^29.x | Testing framework | Already used in project |
| @duckdb/node-api | ^1.x | DuckDB integration | Required for sync layer |
| zod | ^3.x | Schema validation | MCP SDK pattern |
| fs/promises | Node.js | Filesystem operations | Standard for async file ops |
| crypto | Node.js | SHA-256 hashing | Built-in, no deps |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| tmp-promise | ^3.x | Temp directory creation | Integration tests with filesystem |
| fake-indexeddb | ^4.x | IndexedDB mocking | Already used in project tests |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Jest | Vitest | Faster but would require migration |
| tmp-promise | Node.js fs.mkdtemp | tmp-promise has better cleanup handling |

**Installation:**
```bash
npm install --save-dev tmp-promise
```

## Architecture Patterns

### Recommended Tool File Structure
```
packages/mcp-server/src/tools/
├── blocks/                    # Split from blocks.ts
│   ├── index.ts              # Re-exports and registerAllBlockTools()
│   ├── core.ts               # list_blocks, get_block_info, get_statistics, get_reporting_log_stats (~650 lines)
│   ├── comparison.ts         # get_strategy_comparison, compare_blocks, block_diff (~550 lines)
│   ├── analysis.ts           # stress_test, drawdown_attribution, marginal_contribution (~750 lines)
│   ├── similarity.ts         # strategy_similarity, what_if_scaling (~700 lines)
│   └── health.ts             # portfolio_health_check (~700 lines)
├── reports/                   # Split from reports.ts
│   ├── index.ts              # Re-exports and registerAllReportTools()
│   ├── fields.ts             # list_available_fields, get_field_statistics (~400 lines)
│   ├── queries.ts            # run_filtered_query, aggregate_by_field (~500 lines)
│   ├── predictive.ts         # find_predictive_fields, filter_curve (~600 lines)
│   └── slippage.ts           # analyze_discrepancies, suggest_strategy_matches, slippage_trends (~800 lines)
├── middleware/                # NEW: Sync middleware
│   └── sync-middleware.ts    # withSyncedBlock, withSyncedBlocks helpers
├── shared/                    # Shared utilities
│   ├── filters.ts            # filterByStrategy, filterByDateRange (currently duplicated)
│   └── helpers.ts            # calculatePeakExposure, common calculations
├── analysis.ts               # Keep as-is (1,387 lines - moderate but acceptable)
├── market-data.ts            # Keep as-is (1,797 lines - moderate)
├── performance.ts            # Keep as-is (2,570 lines - could split later)
├── imports.ts                # Keep as-is (164 lines)
└── index.ts                  # Master registration
```

### Pattern 1: Sync Middleware Pattern
**What:** Higher-order function that wraps tool handlers with automatic sync behavior
**When to use:** Any tool that needs to ensure fresh data before querying
**Example:**
```typescript
// Source: New pattern for Phase 42.1

// middleware/sync-middleware.ts
import { syncBlock, type BlockSyncResult } from "../sync/index.js";

export interface SyncContext {
  syncResult: BlockSyncResult;
  baseDir: string;
}

/**
 * Middleware that ensures a block is synced before tool execution.
 * Handles the "deleted block" error case automatically.
 */
export function withSyncedBlock<TInput extends { blockId: string }, TOutput>(
  baseDir: string,
  handler: (input: TInput, ctx: SyncContext) => Promise<TOutput>
): (input: TInput) => Promise<TOutput | { content: Array<{ type: "text"; text: string }>; isError: true }> {
  return async (input: TInput) => {
    const syncResult = await syncBlock(input.blockId, baseDir);

    // Handle deleted block case
    if (syncResult.status === "deleted") {
      return {
        content: [
          {
            type: "text" as const,
            text: `Block '${input.blockId}' no longer exists (folder was deleted)`,
          },
        ],
        isError: true as const,
      };
    }

    return handler(input, { syncResult, baseDir });
  };
}

/**
 * Middleware for tools that need multiple blocks synced.
 */
export function withSyncedBlocks<TInput extends { blockIds?: string[]; blockIdA?: string; blockIdB?: string }, TOutput>(
  baseDir: string,
  handler: (input: TInput, ctx: { syncResults: Map<string, BlockSyncResult>; baseDir: string }) => Promise<TOutput>
): (input: TInput) => Promise<TOutput | { content: Array<{ type: "text"; text: string }>; isError: true }> {
  return async (input: TInput) => {
    const blockIds: string[] = input.blockIds ??
      [input.blockIdA, input.blockIdB].filter((id): id is string => !!id);

    const syncResults = new Map<string, BlockSyncResult>();

    for (const blockId of blockIds) {
      const result = await syncBlock(blockId, baseDir);
      syncResults.set(blockId, result);

      if (result.status === "deleted") {
        return {
          content: [
            {
              type: "text" as const,
              text: `Block '${blockId}' no longer exists (folder was deleted)`,
            },
          ],
          isError: true as const,
        };
      }
    }

    return handler(input, { syncResults, baseDir });
  };
}
```

**Usage in tool registration:**
```typescript
// blocks/core.ts
import { withSyncedBlock } from "../middleware/sync-middleware.js";

export function registerCoreBlockTools(server: McpServer, baseDir: string): void {
  // Tool: get_block_info
  server.registerTool(
    "get_block_info",
    {
      description: "Get detailed metadata for a block...",
      inputSchema: z.object({ blockId: z.string() }),
    },
    withSyncedBlock(baseDir, async ({ blockId }, { syncResult }) => {
      // Handler no longer needs sync boilerplate
      const block = await loadBlock(baseDir, blockId);
      // ... rest of handler
    })
  );
}
```

### Pattern 2: Integration Test File Fixture Pattern
**What:** Create temporary directories with realistic block data for sync testing
**When to use:** Testing sync detection, rollback, and edge cases
**Example:**
```typescript
// Source: Jest testing best practices

// tests/integration/sync-layer.test.ts
import * as path from 'path';
import * as fs from 'fs/promises';
import { tmpdir } from 'os';
import { mkdtemp, rm } from 'fs/promises';

describe('Sync Layer Integration', () => {
  let testDir: string;

  beforeEach(async () => {
    // Create isolated temp directory for each test
    testDir = await mkdtemp(path.join(tmpdir(), 'sync-test-'));
  });

  afterEach(async () => {
    // Clean up temp directory
    await rm(testDir, { recursive: true, force: true });
  });

  async function createBlockFixture(blockId: string, trades: string[][]): Promise<string> {
    const blockDir = path.join(testDir, blockId);
    await fs.mkdir(blockDir, { recursive: true });

    const headers = ['Date Opened', 'Time Opened', 'Strategy', 'Legs', 'Premium',
                     'No. of Contracts', 'P/L', 'Date Closed', 'Time Closed',
                     'Reason For Close', 'Margin Req.', 'Opening Commissions + Fees',
                     'Closing Commissions + Fees'];
    const csv = [headers.join(','), ...trades.map(t => t.join(','))].join('\n');

    await fs.writeFile(path.join(blockDir, 'tradelog.csv'), csv);
    return blockDir;
  }

  it('detects new blocks correctly', async () => {
    // Create a new block
    await createBlockFixture('new-block', [
      ['2024-01-02', '09:30:00', 'Test', '', '1.50', '1', '200', '2024-01-02', '15:00:00', 'Profit Target', '500', '1.50', '1.50']
    ]);

    const result = await syncAllBlocks(testDir);

    expect(result.blocksSynced).toBe(1);
    expect(result.blocksUnchanged).toBe(0);
    expect(result.errors).toHaveLength(0);
  });

  it('detects changed blocks correctly', async () => {
    // First sync
    await createBlockFixture('changed-block', [
      ['2024-01-02', '09:30:00', 'Test', '', '1.50', '1', '200', '2024-01-02', '15:00:00', 'Profit Target', '500', '1.50', '1.50']
    ]);
    await syncAllBlocks(testDir);

    // Modify the block
    await createBlockFixture('changed-block', [
      ['2024-01-02', '09:30:00', 'Test', '', '1.50', '1', '200', '2024-01-02', '15:00:00', 'Profit Target', '500', '1.50', '1.50'],
      ['2024-01-03', '09:30:00', 'Test', '', '1.50', '1', '300', '2024-01-03', '15:00:00', 'Profit Target', '500', '1.50', '1.50']
    ]);

    const result = await syncAllBlocks(testDir);

    expect(result.blocksSynced).toBe(1);
    expect(result.blocksUnchanged).toBe(0);
  });

  it('detects deleted blocks correctly', async () => {
    // Create and sync a block
    const blockDir = await createBlockFixture('to-delete', [
      ['2024-01-02', '09:30:00', 'Test', '', '1.50', '1', '200', '2024-01-02', '15:00:00', 'Profit Target', '500', '1.50', '1.50']
    ]);
    await syncAllBlocks(testDir);

    // Delete the block
    await rm(blockDir, { recursive: true });

    const result = await syncAllBlocks(testDir);

    expect(result.blocksDeleted).toBe(1);
  });
});
```

### Anti-Patterns to Avoid
- **Giant function registrations:** Don't put all tool handlers in a single 3000+ line function
- **Duplicated filter logic:** `filterByStrategy` and `filterByDateRange` appear in multiple files
- **Inline sync calls:** Each tool has 10-15 lines of sync boilerplate that can be eliminated
- **Test coupling:** Don't share state between integration tests; use isolated fixtures

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Temp directories | Manual mkdtemp/cleanup | `tmp-promise` or setup/teardown | Cleanup on test failure is tricky |
| Hash comparison | String comparison | Crypto SHA-256 | Already implemented in hasher.ts |
| Transaction rollback | Manual try/catch | DuckDB transactions | Already implemented in block-sync.ts |
| Tool error responses | Ad-hoc objects | `createToolOutput` pattern | Consistent MCP format |

**Key insight:** The sync layer is already well-implemented (transactions, hash detection, rollback). The phase is about testing it thoroughly and reducing boilerplate in consumers.

## Common Pitfalls

### Pitfall 1: Test Isolation Failures
**What goes wrong:** Tests pass individually but fail when run together
**Why it happens:** DuckDB singleton connection shares state between tests
**How to avoid:**
- Call `closeConnection()` in `afterAll` to reset singleton
- Use unique block IDs per test
- Create fresh temp directories per test
**Warning signs:** Flaky tests, "table already exists" errors

### Pitfall 2: File Splitting Breaking Imports
**What goes wrong:** Circular dependencies or missing exports after splitting
**Why it happens:** Large files often have hidden interdependencies
**How to avoid:**
- Create shared/helpers.ts for common utilities first
- Use barrel exports (index.ts) for clean public API
- Run `npm run typecheck` after each split
**Warning signs:** "Cannot find module" errors, TypeScript circular reference warnings

### Pitfall 3: Middleware Type Inference
**What goes wrong:** TypeScript can't infer types through middleware wrappers
**Why it happens:** Generic type inference across function boundaries is complex
**How to avoid:**
- Explicitly type middleware parameters: `withSyncedBlock<{blockId: string}, ToolOutput>`
- Use const assertions for return types
- Keep middleware simple (don't over-abstract)
**Warning signs:** `any` types appearing in tool handlers, IDE losing intellisense

### Pitfall 4: Transaction Scope Mismatch
**What goes wrong:** Partial state on sync failure
**Why it happens:** Rollback only covers what's inside the transaction
**How to avoid:**
- Verify rollback behavior in integration tests
- Test failure scenarios explicitly
- The sync layer already handles this - tests just need to verify it
**Warning signs:** Orphaned metadata entries, trades without matching metadata

## Code Examples

Verified patterns from the existing codebase:

### Existing Tool Registration Pattern
```typescript
// Source: packages/mcp-server/src/tools/blocks.ts:107-262
export function registerBlockTools(server: McpServer, baseDir: string): void {
  server.registerTool(
    "list_blocks",
    {
      description: "START HERE: List all available portfolio blocks...",
      inputSchema: z.object({
        sortBy: z.enum(["name", "tradeCount", "netPl", "dateRange"]).default("name"),
        // ... more options
      }),
    },
    async ({ sortBy, sortOrder, ... }) => {
      try {
        // Current pattern: sync inline at start of handler
        const syncResult = await syncAllBlocks(baseDir);
        const marketSyncResult = await syncMarketData(baseDir);

        // ... business logic

        return createToolOutput(summary, structuredData);
      } catch (error) {
        return {
          content: [{ type: "text", text: `Error: ${(error as Error).message}` }],
          isError: true,
        };
      }
    }
  );
}
```

### Existing Transaction Pattern in Sync
```typescript
// Source: packages/mcp-server/src/sync/block-sync.ts:328-395
await conn.run("BEGIN TRANSACTION");
try {
  // Delete old trade data
  await conn.run("DELETE FROM trades.trade_data WHERE block_id = $1", [blockId]);

  // Insert new trades in batches
  for (let i = 0; i < records.length; i += batchSize) {
    await insertTradeBatch(conn, blockId, records, i, batchSize);
  }

  // Update metadata
  await upsertSyncMetadata(conn, newMetadata);

  await conn.run("COMMIT");
  return { blockId, status: "synced", tradeCount: records.length };
} catch (err) {
  await conn.run("ROLLBACK");
  // If previously synced, clean up to avoid stale state
  if (existingMetadata) {
    // ... cleanup logic
  }
  throw err;
}
```

### Shared Filter Functions (Currently Duplicated)
```typescript
// Source: packages/mcp-server/src/tools/blocks.ts:29-65
// Also duplicated in reports.ts:318-351

function filterByStrategy(trades: Trade[], strategy?: string): Trade[] {
  if (!strategy) return trades;
  return trades.filter(
    (t) => t.strategy.toLowerCase() === strategy.toLowerCase()
  );
}

function filterByDateRange(
  trades: Trade[],
  startDate?: string,
  endDate?: string
): Trade[] {
  let filtered = trades;
  if (startDate) {
    const start = new Date(startDate);
    if (!isNaN(start.getTime())) {
      filtered = filtered.filter((t) => new Date(t.dateOpened) >= start);
    }
  }
  if (endDate) {
    const end = new Date(endDate);
    if (!isNaN(end.getTime())) {
      end.setHours(23, 59, 59, 999);
      filtered = filtered.filter((t) => new Date(t.dateOpened) <= end);
    }
  }
  return filtered;
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Monolithic tool files | Domain-split modules | Phase 42.1 (proposed) | Better maintainability, <800 lines/file |
| Inline sync in handlers | Middleware pattern | Phase 42.1 (proposed) | ~15 lines removed per tool |
| Manual test fixtures | Temp directory fixtures | Phase 42.1 (proposed) | Isolated, reproducible tests |

**Deprecated/outdated:**
- N/A - This is a new pattern introduction, not a migration

## Open Questions

Things that couldn't be fully resolved:

1. **Should middleware handle error formatting?**
   - What we know: Current tools all format errors the same way
   - What's unclear: Whether middleware should also wrap try/catch
   - Recommendation: Keep middleware focused on sync; let handlers format their own errors

2. **How to handle tools that need syncAllBlocks?**
   - What we know: `list_blocks` calls `syncAllBlocks` (full scan)
   - What's unclear: Should there be a separate `withFullSync` middleware?
   - Recommendation: Create separate middleware for the single tool that needs it

3. **Should reports.ts tools integrate sync?**
   - What we know: reports.ts tools don't currently call sync
   - What's unclear: Phase 42 decisions about which tools need sync
   - Recommendation: Add sync to reports.ts tools via middleware as part of this phase (matches Phase 42's 14-tool integration goal)

## Sources

### Primary (HIGH confidence)
- `/Users/davidromeo/Code/tradeblocks/packages/mcp-server/src/sync/` - Read all 5 files (1,243 lines total)
- `/Users/davidromeo/Code/tradeblocks/packages/mcp-server/src/tools/blocks.ts` - Read entire file (3,374 lines)
- `/Users/davidromeo/Code/tradeblocks/packages/mcp-server/src/tools/reports.ts` - Read entire file (3,338 lines)
- `/Users/davidromeo/Code/tradeblocks/packages/mcp-server/tests/` - Examined existing test patterns

### Secondary (MEDIUM confidence)
- Jest testing best practices (training data)
- Node.js filesystem testing patterns (training data)
- TypeScript module splitting patterns (training data)

### Tertiary (LOW confidence)
- None

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Using existing project dependencies
- Architecture: HIGH - Based on direct analysis of existing code patterns
- Pitfalls: HIGH - Derived from actual code structure and common patterns
- Middleware pattern: MEDIUM - Novel pattern but based on common practices

**Research date:** 2026-02-01
**Valid until:** 60 days (stable codebase, no external dependencies changing)

---

## Appendix: File Line Counts

### Current Tool Files
| File | Lines | Tools | Status |
|------|-------|-------|--------|
| blocks.ts | 3,374 | 14 | NEEDS SPLIT |
| reports.ts | 3,338 | 9 | NEEDS SPLIT |
| performance.ts | 2,570 | - | Monitor |
| market-data.ts | 1,797 | - | OK |
| analysis.ts | 1,387 | - | OK |
| imports.ts | 164 | - | OK |

### Sync Layer Files
| File | Lines | Purpose |
|------|-------|---------|
| block-sync.ts | 527 | Core sync logic |
| market-sync.ts | 336 | Market data sync |
| index.ts | 182 | Public API |
| metadata.ts | 177 | CRUD for sync metadata |
| hasher.ts | 21 | SHA-256 hashing |
| **Total** | **1,243** | Well-structured |

### Proposed Split (blocks.ts -> blocks/)
| New File | Est. Lines | Tools |
|----------|-----------|-------|
| core.ts | ~650 | list_blocks, get_block_info, get_statistics, get_reporting_log_stats |
| comparison.ts | ~550 | get_strategy_comparison, compare_blocks, block_diff |
| analysis.ts | ~750 | stress_test, drawdown_attribution, marginal_contribution |
| similarity.ts | ~700 | strategy_similarity, what_if_scaling |
| health.ts | ~700 | portfolio_health_check |
| index.ts | ~50 | Re-exports |

### Proposed Split (reports.ts -> reports/)
| New File | Est. Lines | Tools |
|----------|-----------|-------|
| fields.ts | ~400 | list_available_fields, get_field_statistics |
| queries.ts | ~500 | run_filtered_query, aggregate_by_field |
| predictive.ts | ~600 | find_predictive_fields, filter_curve |
| slippage.ts | ~800 | analyze_discrepancies, suggest_strategy_matches, slippage_trends |
| index.ts | ~50 | Re-exports |
