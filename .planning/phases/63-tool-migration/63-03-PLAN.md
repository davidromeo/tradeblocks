---
phase: 63-tool-migration
plan: 03
type: execute
wave: 3
depends_on: ["63-02"]
files_modified:
  - packages/mcp-server/src/tools/market-data.ts
  - packages/mcp-server/package.json
autonomous: true
requirements: [MIG-05]

must_haves:
  truths:
    - "calculate_orb queries market.intraday with time range filter using HH:MM format"
    - "ORB output includes per-day breakout events (direction, time, breakout condition, entry_triggered boolean) aligned with Option Omega model"
    - "Bar resolution parameter defaults to finest available resolution and can be overridden"
    - "HHMM input format (e.g., '0930') is converted to HH:MM (e.g., '09:30') before SQL comparison"
    - "Missing intraday data produces actionable warning via checkDataAvailability, not hard error"
  artifacts:
    - path: "packages/mcp-server/src/tools/market-data.ts"
      provides: "Redesigned calculate_orb tool querying market.intraday"
      contains: "market.intraday"
    - path: "packages/mcp-server/package.json"
      provides: "Version bump to 1.5.0"
      contains: "1.5.0"
  key_links:
    - from: "packages/mcp-server/src/tools/market-data.ts"
      to: "market.intraday"
      via: "SQL query with time range filter"
      pattern: "market\\.intraday"
---

<objective>
Redesign the calculate_orb tool from scratch to work with the unpivoted market.intraday table, aligning with Option Omega's ORB model (breakout conditions, bar resolution, high-low values toggle).

Purpose: The old ORB tool read pivoted checkpoint columns (P_0930, P_0945, etc.) from market.spx_15min. The new market.intraday table stores one row per bar with (ticker, date, time, open, high, low, close). ORB must be computed via SQL aggregation over bars within the time window, plus breakout detection on post-window bars.

Output: Redesigned calculate_orb in market-data.ts, version bump to 1.5.0.
</objective>

<execution_context>
@/Users/davidromeo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidromeo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/63-tool-migration/63-CONTEXT.md
@.planning/phases/63-tool-migration/63-RESEARCH.md
@.planning/phases/63-tool-migration/63-02-SUMMARY.md
@packages/mcp-server/src/tools/market-data.ts
@packages/mcp-server/src/utils/data-availability.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Redesign calculate_orb for market.intraday with breakout detection</name>
  <files>packages/mcp-server/src/tools/market-data.ts</files>
  <action>
Fully replace the `calculate_orb` tool registration in market-data.ts.

**1. New input schema** aligned with Option Omega ORB model:
```typescript
z.object({
  ticker: z.string().optional().describe("Underlying ticker (default: SPX)"),
  startTime: z.string().describe("ORB window start time in HHMM format (e.g., '0930')"),
  endTime: z.string().describe("ORB window end time in HHMM format (e.g., '1000')"),
  startDate: z.string().describe("Start date (YYYY-MM-DD)"),
  endDate: z.string().optional().describe("End date (YYYY-MM-DD), defaults to startDate"),
  useHighLow: z.boolean().default(true).describe(
    "If true, ORB range uses bar high/low values. If false, uses bar close values only. Default: true."
  ),
  barResolution: z.string().optional().describe(
    "Bar resolution to use (e.g., '15', '5'). Default: finest available resolution in market.intraday for the ticker."
  ),
  limit: z.number().int().min(1).max(500).default(100).describe("Max days to return (default: 100)"),
})
```

**2. Time format conversion helper:**
Add a local helper function (or inline):
```typescript
function hhmmToSqlTime(hhmm: string): string {
  if (!/^\d{4}$/.test(hhmm)) throw new Error(`Invalid HHMM format: ${hhmm}. Expected 4 digits like '0930'.`);
  return `${hhmm.slice(0, 2)}:${hhmm.slice(2)}`;
}
```

**3. Validate inputs:**
- Convert startTime and endTime to HH:MM format
- Verify startTime < endTime (string comparison works for HH:MM)

**4. Determine bar resolution:**
If `barResolution` not provided, query for the finest available:
```sql
SELECT DISTINCT time FROM market.intraday
WHERE ticker = $1 AND date = (SELECT MIN(date) FROM market.intraday WHERE ticker = $1)
ORDER BY time
LIMIT 10
```
Compute the resolution from the time gap between consecutive bars. If no bars found, return early with warning.

If `barResolution` is provided, filter bars by resolution (e.g., for 15-min bars, only use times at 15-min intervals: 09:30, 09:45, 10:00, etc.).

**5. Integrate checkDataAvailability:**
```typescript
const availability = await checkDataAvailability(conn, normalizedTicker, { checkIntraday: true });
if (!availability.hasIntradayData) {
  return createToolOutput(
    `ORB: No intraday data for ${normalizedTicker}`,
    {
      query: { ticker: normalizedTicker, startTime, endTime, startDate, endDate: end },
      warnings: availability.warnings,
      days: [],
      stats: { totalDays: 0 },
    }
  );
}
```

**6. Main ORB query using DuckDB SQL:**
Execute the SQL pattern from research (Pattern 2), adapted for the useHighLow toggle:

```sql
WITH orb_range AS (
  SELECT
    ticker, date,
    ${useHighLow ? 'MAX(high)' : 'MAX(close)'} AS ORB_High,
    ${useHighLow ? 'MIN(low)' : 'MIN(close)'} AS ORB_Low,
    ${useHighLow ? 'MAX(high) - MIN(low)' : 'MAX(close) - MIN(close)'} AS ORB_Range,
    MIN(open) FILTER (WHERE time = $sqlStartTime) AS ORB_Open
  FROM market.intraday
  WHERE ticker = $1
    AND date BETWEEN $2 AND $3
    AND time >= $4  -- sqlStartTime
    AND time <= $5  -- sqlEndTime
  GROUP BY ticker, date
),
breakout_events AS (
  SELECT
    i.ticker, i.date,
    MIN(i.time) FILTER (WHERE ${useHighLow ? 'i.high' : 'i.close'} > r.ORB_High) AS breakout_up_time,
    MIN(i.time) FILTER (WHERE ${useHighLow ? 'i.low' : 'i.close'} < r.ORB_Low) AS breakout_down_time
  FROM market.intraday i
  JOIN orb_range r ON i.ticker = r.ticker AND i.date = r.date
  WHERE i.time > $5  -- post-ORB window
  GROUP BY i.ticker, i.date
)
SELECT
  r.date,
  r.ORB_High,
  r.ORB_Low,
  r.ORB_Range,
  CASE WHEN r.ORB_Low > 0 THEN r.ORB_Range / r.ORB_Low * 100 ELSE 0 END AS ORB_Range_Pct,
  r.ORB_Open,
  b.breakout_up_time,
  b.breakout_down_time,
  CASE
    WHEN b.breakout_up_time IS NOT NULL AND b.breakout_down_time IS NOT NULL THEN
      CASE WHEN b.breakout_up_time < b.breakout_down_time THEN 'HighFirst' ELSE 'LowFirst' END
    WHEN b.breakout_up_time IS NOT NULL THEN 'HighOnly'
    WHEN b.breakout_down_time IS NOT NULL THEN 'LowOnly'
    ELSE 'NoBreakout'
  END AS breakout_condition
FROM orb_range r
LEFT JOIN breakout_events b ON r.ticker = b.ticker AND r.date = b.date
ORDER BY r.date
```

Note: Use parameterized queries. The `useHighLow` toggle affects which expression is used (this is string interpolation in the SQL template, not a parameter). The ticker, dates, and times are parameters.

**7. Process results:**
Convert DuckDB results to records. For each row:
```typescript
{
  date: string,
  ORB_High: number,
  ORB_Low: number,
  ORB_Range: number,
  ORB_Range_Pct: number,
  ORB_Open: number | null,
  breakout_condition: 'HighFirst' | 'LowFirst' | 'HighOnly' | 'LowOnly' | 'NoBreakout',
  breakout_up_time: string | null,  // HH:MM or null
  breakout_down_time: string | null, // HH:MM or null
  entry_triggered: boolean,  // true when breakout_condition !== 'NoBreakout'
}
```

The `entry_triggered` field is an explicit boolean indicating whether a breakout entry would have triggered on that day. Per locked user decision, this is a distinct output element alongside direction and time. Computed as: `entry_triggered = breakout_condition !== 'NoBreakout'`.

**8. Compute aggregate stats:**
```typescript
{
  totalDays,
  avgOrbRangePct,
  breakdownByCondition: {
    HighFirst: count,
    LowFirst: count,
    HighOnly: count,
    LowOnly: count,
    NoBreakout: count,
  },
}
```

**9. Build response:**
Apply limit. Include query metadata (ticker, times, resolution, useHighLow), stats, warnings, and day-level results.

**10. Update tool description:**
```
"Calculate Opening Range Breakout (ORB) levels from market.intraday bar data. " +
"ORB range defined by high/low (or close) within the specified time window. " +
"Returns per-day ORB levels plus breakout events (direction, time, condition). " +
"Supports any bar resolution and any ticker with intraday data."
```

**11. Remove old checkpoint-based code:**
Delete the `checkpointFields` map, all P_HHMM references, and the old ORB calculation loop. The entire `calculate_orb` handler is replaced.

**Important:**
- HHMM to HH:MM conversion MUST happen before SQL: '0930' -> '09:30'
- Do NOT reference market.spx_15min anywhere
- Use LEFT JOIN for breakout_events (some days may have no breakout)
  </action>
  <verify>
`npx tsc --noEmit -p packages/mcp-server/tsconfig.json` compiles. `grep -n "spx_15min\|P_0930\|checkpointFields" packages/mcp-server/src/tools/market-data.ts` returns zero matches.
  </verify>
  <done>
calculate_orb queries market.intraday with SQL aggregation over bars in the ORB time window. Breakout detection uses post-window bars. Each per-day result includes `entry_triggered: boolean` (true when breakout_condition !== 'NoBreakout'). useHighLow toggle controls whether high/low or close values define the range. HHMM input correctly converted to HH:MM for SQL. Optional barResolution parameter with auto-detection. checkDataAvailability integrated. Zero references to old table names or checkpoint columns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Version bump and final cleanup</name>
  <files>
    packages/mcp-server/package.json
    packages/mcp-server/src/tools/market-data.ts
  </files>
  <action>
**1. Version bump:**
Update `packages/mcp-server/package.json` version from `"1.4.0"` to `"1.5.0"` (minor bump for migrated tools with new capabilities).

**2. Final cleanup in market-data.ts:**
- Remove the `DailyMarketData` interface (or replace with a brief comment: `// Daily market data now in market.daily — see market-schemas.ts for schema`)
- Remove the `Intraday15MinData` interface (or replace with: `// Intraday data now in market.intraday — see market-schemas.ts for schema`)
- Update the module-level docstring at the top of market-data.ts:
```typescript
/**
 * Market Data Tools
 *
 * MCP tools for analyzing market context and correlating with trade performance.
 * Includes enrich_trades for lag-aware trade enrichment, regime analysis,
 * filter suggestions, and Opening Range Breakout calculations.
 *
 * Data source: DuckDB normalized schema
 * - market.daily: Per-ticker OHLCV + enrichment indicators
 * - market.context: Global VIX/regime context (joined via date)
 * - market.intraday: Raw bar data for ORB and intraday analysis
 */
```

**3. Verify zero old references:**
Confirm no remaining references to `spx_daily`, `spx_15min`, or `vix_intraday` in the entire file (SQL strings, comments, docstrings). The only acceptable mention would be in a migration comment like `// Migrated from spx_daily in Phase 63` — but even this is unnecessary and should be avoided.

**4. Build the MCP server:**
```bash
cd packages/mcp-server && npm run build
```
Verify successful compilation.
  </action>
  <verify>
`cd packages/mcp-server && npm run build` succeeds. `grep -rn "spx_daily\|spx_15min\|vix_intraday" packages/mcp-server/src/tools/market-data.ts` returns zero matches. `grep '"version"' packages/mcp-server/package.json` shows `"1.5.0"`.
  </verify>
  <done>
MCP server version bumped to 1.5.0. market-data.ts has no references to old table names. Old interface types removed. Module docstring updated. Build succeeds.
  </done>
</task>

</tasks>

<verification>
1. `cd packages/mcp-server && npm run build` — successful compilation
2. `grep -rn "spx_daily\|spx_15min\|vix_intraday" packages/mcp-server/src/tools/market-data.ts` — zero matches
3. `grep "breakout_condition" packages/mcp-server/src/tools/market-data.ts` — present (ORB breakout detection implemented)
4. `grep "entry_triggered" packages/mcp-server/src/tools/market-data.ts` — present (explicit entry triggered boolean field)
5. `grep '"version"' packages/mcp-server/package.json` — shows 1.5.0
6. `grep "hhmmToSqlTime\|hhmm4ToSqlTime\|HH:MM" packages/mcp-server/src/tools/market-data.ts` — time format conversion present
</verification>

<success_criteria>
- calculate_orb fully redesigned for market.intraday with SQL aggregation
- Breakout detection (HighFirst, LowFirst, HighOnly, LowOnly, NoBreakout) implemented
- Per-day results include explicit `entry_triggered: boolean` field (true when breakout_condition !== 'NoBreakout')
- useHighLow toggle controls range definition (high/low vs close)
- barResolution parameter with auto-detection
- HHMM -> HH:MM conversion before SQL comparison
- checkDataAvailability integrated with actionable warnings
- MCP server version bumped to 1.5.0
- Zero references to old table names in market-data.ts
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/63-tool-migration/63-03-SUMMARY.md`
</output>
