---
phase: 63-tool-migration
plan: 02
type: execute
wave: 2
depends_on: ["63-01"]
files_modified:
  - packages/mcp-server/src/tools/market-data.ts
  - packages/mcp-server/src/utils/market-enricher.ts
autonomous: true
requirements: [MIG-01, MIG-02, MIG-03, MIG-04, MIG-08]

must_haves:
  truths:
    - "enrich_trades returns sameDay/priorDay fields from both market.daily and market.context, including new fields BB_Width, Realized_Vol_5D/20D, Prior_Range_vs_ATR, BB_Position"
    - "Prior_Range_vs_ATR is computed by the enricher and written to market.daily, exposed as an open-known field in enrich_trades output"
    - "analyze_regime_performance segments trades using data from the joined daily+context result, with Vol_Regime and Term_Structure_State from market.context"
    - "suggest_filters includes new enrichment field filter candidates (BB_Width, Realized_Vol_5D, Realized_Vol_20D, Prior_Range_vs_ATR) as standalone filters AND generates composite filter suggestions where cross-field correlations are strong"
    - "All three tools include a warnings array from checkDataAvailability when market data is partially missing"
    - "Zero references to spx_daily, spx_15min, or vix_intraday in market-data.ts"
  artifacts:
    - path: "packages/mcp-server/src/tools/market-data.ts"
      provides: "Migrated enrich_trades, analyze_regime_performance, suggest_filters tools"
      contains: "market.daily"
  key_links:
    - from: "packages/mcp-server/src/tools/market-data.ts"
      to: "packages/mcp-server/src/utils/field-timing.ts"
      via: "buildLookaheadFreeQuery import"
      pattern: "import.*buildLookaheadFreeQuery"
    - from: "packages/mcp-server/src/tools/market-data.ts"
      to: "packages/mcp-server/src/utils/data-availability.ts"
      via: "checkDataAvailability import"
      pattern: "import.*checkDataAvailability"
---

<objective>
Migrate three market-data tools (enrich_trades, analyze_regime_performance, suggest_filters) to the new normalized schema with dual-table JOINs, new enrichment field exposure, and actionable missing-data warnings.

Purpose: These tools currently query the old `market.spx_daily` monolithic table. They must be updated to use the new `buildLookaheadFreeQuery` (which JOINs `market.daily + market.context`) and integrate `checkDataAvailability` for graceful degradation.

Output: Updated market-data.ts with three migrated tools, new filter candidates, and warnings integration.
</objective>

<execution_context>
@/Users/davidromeo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidromeo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/63-tool-migration/63-CONTEXT.md
@.planning/phases/63-tool-migration/63-RESEARCH.md
@.planning/phases/63-tool-migration/63-01-SUMMARY.md
@packages/mcp-server/src/tools/market-data.ts
@packages/mcp-server/src/utils/field-timing.ts
@packages/mcp-server/src/utils/data-availability.ts
@packages/mcp-server/src/utils/intraday-timing.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate enrich_trades to new schema with new field exposure + add Prior_Range_vs_ATR to enricher</name>
  <files>
    packages/mcp-server/src/tools/market-data.ts
    packages/mcp-server/src/utils/market-enricher.ts
  </files>
  <action>
**FIRST: Add Prior_Range_vs_ATR computation to the enricher (`market-enricher.ts`):**

Per locked user decision, `enrich_trades` must expose `Prior_Range_vs_ATR`. The column was added to `market.daily` schema in Plan 01, but the enricher doesn't compute it yet (documented as schema gap at line ~691).

1. In the Tier 1 enrichment function, compute `Prior_Range_vs_ATR` for each bar:
   ```typescript
   // Prior_Range_vs_ATR = prior day's (high - low) / ATR
   // This is the prior day's range as a proportion of ATR, known at market open.
   // For bar i: Prior_Range_vs_ATR[i] = (high[i-1] - low[i-1]) / ATR[i-1]
   // First bar: NaN (no prior day)
   ```
   The ATR values are already computed by `computeATR()`. The prior day's high and low are available from the input arrays. Compute this AFTER ATR is available.

2. Add `Prior_Range_vs_ATR` to the UPDATE SET in the enricher's upsert SQL (alongside BB_Width, Realized_Vol_5D, etc.).

3. Remove the schema gap comment about `Prior_Range_vs_ATR` from the enricher docstring (line ~691), since the column now exists and is being written.

**THEN: Update the `enrich_trades` tool handler in market-data.ts:**

**1. Import checkDataAvailability:**
Add `import { checkDataAvailability } from "../utils/data-availability.js";` at the top.

**2. Add optional `ticker` parameter:**
Add `ticker: z.string().optional().describe("Underlying ticker symbol (default: SPX)")` to the input schema.

**3. Integrate checkDataAvailability at handler start:**
After loading trades and before querying, call:
```typescript
const resolvedTicker = normalizeTicker(ticker || '') || DEFAULT_MARKET_TICKER;
const availability = await checkDataAvailability(conn, resolvedTicker);
```
If `!availability.hasDailyData`, return partial results with `availability.warnings` instead of `isError: true`.

**4. Update buildLookaheadFreeQuery call:**
The updated `buildLookaheadFreeQuery` (from Plan 01) already JOINs daily + context. The call site remains the same — pass `tradeKeys` and get back SQL that queries both tables. No changes needed to the query call itself, just verify the returned records now include context fields (VIX_Open, Vol_Regime, etc.) from the JOIN.

**5. Update sameDay/priorDay field iteration:**
The `OPEN_KNOWN_FIELDS`, `CLOSE_KNOWN_FIELDS`, and `STATIC_FIELDS` sets (from Plan 01) now include fields from both tables. The existing iteration code (`for (const field of OPEN_KNOWN_FIELDS)`) will automatically pick up context fields. No code change needed for the iteration — it works because the LAG CTE now includes all fields from both tables.

**6. Update intraday context queries:**
Replace `market.spx_15min` with `market.intraday`. The intraday table is now unpivoted (one row per bar). The intraday context feature currently reads checkpoint columns (P_0930, etc.) from wide-format rows. Since `market.intraday` doesn't have these columns, the intraday context queries need updating:

For the SPX intraday query, change from:
```sql
SELECT s.* FROM market.spx_15min s JOIN requested r ON s.ticker = r.ticker AND s.date = r.date
```
To a query that pivots market.intraday bars into checkpoint-style key-value pairs:
```sql
WITH requested(ticker, date) AS (VALUES ...)
SELECT i.ticker, i.date,
  MAX(CASE WHEN i.time = '09:30' THEN i.close END) AS "P_0930",
  MAX(CASE WHEN i.time = '09:45' THEN i.close END) AS "P_0945",
  ... (all SPX_CHECKPOINTS)
  i.open as open
FROM market.intraday i
JOIN requested r ON i.ticker = r.ticker AND i.date = r.date
GROUP BY i.ticker, i.date, i.open
```

Wait — this is complex and the intraday data can't currently be imported (STATE.md blocker). Per research Open Question 1 recommendation: **Update the SQL to reference `market.intraday` (for correctness) but retain the feature flag**. With zero intraday data, the queries will return empty results and intraday context will be null for all trades (graceful degradation). The `buildIntradayContext` function from `intraday-timing.ts` works on whatever key-value pairs come from the query.

Simpler approach: query market.intraday and pivot in SQL to produce the same checkpoint column format the `buildIntradayContext` expects:
```sql
SELECT ticker, date,
  MAX(CASE WHEN time = '09:30' THEN close END) AS "P_0930",
  MAX(CASE WHEN time = '09:45' THEN close END) AS "P_0945",
  ...etc for all SPX checkpoint times...
  MIN(CASE WHEN time = (SELECT MIN(time) FROM market.intraday i2 WHERE i2.ticker = i.ticker AND i2.date = i.date) THEN open END) as open
FROM market.intraday i
WHERE (ticker, date) IN (SELECT ticker, date FROM requested)
GROUP BY ticker, date
```

Actually, this is getting complex for data that doesn't exist yet. **Simplest correct approach**: Keep the `buildIntradayContext` function and its checkpoint-based logic unchanged (it works on any Record). For the SQL query, pivot the unpivoted bars back into the wide format the function expects. Use a generated CASE-WHEN pivot for each SPX and VIX checkpoint time.

For VIX intraday, similarly pivot `market.intraday WHERE ticker = 'VIX'` bars into VIX_HHMM columns.

If this creates too much complexity, it is acceptable to skip the pivot and return null for intraday context when data comes from market.intraday (the data doesn't exist anyway due to the import blocker). Document with a TODO comment.

**7. Update tool description** to reference new table names and new fields:
```
"Enrich trades with market context from market.daily and market.context using correct temporal joins. " +
"Open-known fields (Gap_Pct, VIX_Open, Prior_Range_vs_ATR) use same-day values. " +
"Close-derived fields (VIX_Close, RSI_14, Vol_Regime, BB_Width, Realized_Vol) use prior trading day values. " +
"New enrichment fields: BB_Width, Realized_Vol_5D, Realized_Vol_20D, BB_Position, Prior_Range_vs_ATR."
```

**8. Add warnings to response:**
Include `availability.warnings` in the response data if non-empty:
```typescript
if (availability.warnings.length > 0) {
  responseData.warnings = availability.warnings;
}
```

**9. Update DailyMarketData interface** (documentation reference) to remove fields not in new schema and add new fields.

**10. Remove Intraday15MinData interface** or replace with a simple comment referencing market.intraday schema.

**Important anti-patterns to avoid:**
- Do NOT reference `market.spx_daily`, `market.spx_15min`, or `market.vix_intraday` in ANY SQL string
- Do NOT hard-fail with `isError: true` when market data is partially available — return partial results + warnings
  </action>
  <verify>
`npx tsc --noEmit -p packages/mcp-server/tsconfig.json` compiles. `grep -n "spx_daily\|spx_15min\|vix_intraday" packages/mcp-server/src/tools/market-data.ts` returns zero matches (excluding comments about migration).
  </verify>
  <done>
market-enricher.ts computes Prior_Range_vs_ATR and writes it to market.daily (schema gap comment removed). enrich_trades queries market.daily JOIN market.context via buildLookaheadFreeQuery. sameDay/priorDay includes new enrichment fields (BB_Width, Realized_Vol_5D/20D, Prior_Range_vs_ATR, BB_Position). Prior_Range_vs_ATR appears as an open-known sameDay field. Intraday context queries reference market.intraday. checkDataAvailability warnings included in response.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate analyze_regime_performance and suggest_filters with new filter candidates</name>
  <files>packages/mcp-server/src/tools/market-data.ts</files>
  <action>
Update both tools in market-data.ts:

**analyze_regime_performance updates:**

1. Add optional `ticker` parameter: `ticker: z.string().optional().describe("Underlying ticker (default: SPX)")`

2. Integrate checkDataAvailability at handler start (same pattern as enrich_trades). Include warnings in response.

3. The buildLookaheadFreeQuery call already returns data from both tables (Plan 01 update). The segment-by logic reads `prev_Vol_Regime` and `prev_Term_Structure_State` — these fields now come from market.context via the JOIN. Since the LAG CTE includes context fields with the same `prev_` prefix, **no changes needed to the segmentation logic itself**.

4. Update tool description to reference new tables:
```
"Break down performance by market regime using market.daily and market.context. " +
"Close-derived fields (volRegime, termStructure) use prior trading day values."
```

5. Per Claude's discretion decision: Keep focused on existing VIX/vol regimes. Do NOT add BB_Width quartile or Realized_Vol regime segmentation in this phase. Add a code comment: `// Future: BB_Width quartile and Realized_Vol regime segmentation dimensions can be added here`

6. Include `availability.warnings` in response when non-empty.

**suggest_filters updates:**

1. Add optional `ticker` parameter: `ticker: z.string().optional().describe("Underlying ticker (default: SPX)")`

2. Integrate checkDataAvailability at handler start. Include warnings in response.

3. **Add new enrichment field filter candidates** to the `testFilters` array (per MIG-04):

```typescript
// NEW: BB_Width filters (close-derived, from daily)
{
  name: "Skip when prior-day BB_Width > 0.05 (wide bands = high vol)",
  field: "BB_Width",
  operator: ">",
  value: 0.05,
  test: (m) => getNum(m, "prev_BB_Width") > 0.05,
  lagged: true,
},
{
  name: "Skip when prior-day BB_Width < 0.02 (narrow bands = compression)",
  field: "BB_Width",
  operator: "<",
  value: 0.02,
  test: (m) => getNum(m, "prev_BB_Width") < 0.02,
  lagged: true,
},
// NEW: Realized Vol filters (close-derived, from daily)
{
  name: "Skip when prior-day 5D realized vol > 1.5%",
  field: "Realized_Vol_5D",
  operator: ">",
  value: 1.5,
  test: (m) => getNum(m, "prev_Realized_Vol_5D") > 1.5,
  lagged: true,
},
{
  name: "Skip when prior-day 20D realized vol > 1.2%",
  field: "Realized_Vol_20D",
  operator: ">",
  value: 1.2,
  test: (m) => getNum(m, "prev_Realized_Vol_20D") > 1.2,
  lagged: true,
},
// NEW: BB_Position filters (close-derived, from daily)
{
  name: "Skip when prior-day BB_Position > 0.9 (near upper band)",
  field: "BB_Position",
  operator: ">",
  value: 0.9,
  test: (m) => getNum(m, "prev_BB_Position") > 0.9,
  lagged: true,
},
{
  name: "Skip when prior-day BB_Position < 0.1 (near lower band)",
  field: "BB_Position",
  operator: "<",
  value: 0.1,
  test: (m) => getNum(m, "prev_BB_Position") < 0.1,
  lagged: true,
},
```

4. **Add Prior_Range_vs_ATR filter candidate** (open-known, same-day value — no LAG needed):
```typescript
// NEW: Prior_Range_vs_ATR filter (open-known, from daily — same-day value)
{
  name: "Skip when Prior_Range_vs_ATR > 1.5 (prior day had outsized range)",
  field: "Prior_Range_vs_ATR",
  operator: ">",
  value: 1.5,
  test: (m) => getNum(m, "Prior_Range_vs_ATR") > 1.5,
  lagged: false,  // open-known field, uses same-day value
},
{
  name: "Skip when Prior_Range_vs_ATR < 0.5 (prior day had compressed range)",
  field: "Prior_Range_vs_ATR",
  operator: "<",
  value: 0.5,
  test: (m) => getNum(m, "Prior_Range_vs_ATR") < 0.5,
  lagged: false,
},
```

5. **Generate composite filter suggestions where cross-field correlations are strong:**

After evaluating all standalone filters, analyze pairs of top-performing standalone filters to find composite candidates. Implementation:

```typescript
// After standalone filter evaluation, find composite pairs:
const significantFilters = suggestions.filter(s => s.projectedWinRate > baseWinRate + 3);
const compositeSuggestions: FilterSuggestion[] = [];

for (let i = 0; i < significantFilters.length; i++) {
  for (let j = i + 1; j < significantFilters.length; j++) {
    const filterA = significantFilters[i];
    const filterB = significantFilters[j];

    // Find trades that match BOTH filters
    const bothMatchTrades = matchedTrades.filter(t => {
      const m = t.marketData;
      return filterA.test(m) && filterB.test(m);
    });

    if (bothMatchTrades.length < 5) continue; // Need minimum sample size

    const compositeWinRate = bothMatchTrades.filter(t => t.pl > 0).length / bothMatchTrades.length * 100;
    const compositeAvgPl = bothMatchTrades.reduce((sum, t) => sum + t.pl, 0) / bothMatchTrades.length;

    // Only surface if composite is materially better than either filter alone
    const improvement = compositeWinRate - Math.max(filterA.projectedWinRate, filterB.projectedWinRate);
    if (improvement > 2) {  // At least 2pp better than the best standalone
      compositeSuggestions.push({
        name: `${filterA.name} AND ${filterB.name}`,
        type: "composite",
        projectedWinRate: compositeWinRate,
        projectedAvgPl: compositeAvgPl,
        tradesAffected: bothMatchTrades.length,
        improvement: improvement,
      });
    }
  }
}
```

Add `compositeSuggestions` to the response alongside `suggestions`. Limit to top 5 composites by improvement. This addresses the locked decision: "generates composite filter suggestions where cross-field correlations are strong."

6. Update the lagNote to include new fields:
```
"Close-derived fields (..., BB_Width, Realized_Vol_5D, Realized_Vol_20D, BB_Position) use prior trading day values. " +
"Open-known fields (Prior_Range_vs_ATR) use same-day values."
```

7. Update tool description to reference new tables, new field candidates, and composite suggestions.

8. Include `availability.warnings` in response when non-empty.

**Both tools:** Ensure the `buildLookaheadFreeQuery` import still works (it was updated in Plan 01 to produce JOIN SQL). The downstream code reads `prev_*` fields from the result — these field names are unchanged.
  </action>
  <verify>
`npx tsc --noEmit -p packages/mcp-server/tsconfig.json` compiles. `grep -n "spx_daily\|spx_15min\|vix_intraday" packages/mcp-server/src/tools/market-data.ts` returns zero matches. `grep -n "composite\|compositeSuggestions" packages/mcp-server/src/tools/market-data.ts` shows composite filter logic present. `grep -n "Prior_Range_vs_ATR" packages/mcp-server/src/tools/market-data.ts` shows filter candidate present.
  </verify>
  <done>
analyze_regime_performance and suggest_filters work against joined daily+context data. suggest_filters has 8 new standalone filter candidates (BB_Width x2, Realized_Vol_5D, Realized_Vol_20D, BB_Position x2, Prior_Range_vs_ATR x2) AND generates composite filter suggestions from pairs of top-performing standalone filters where the combination improves win rate by 2+ percentage points. Both tools include checkDataAvailability warnings. Optional ticker parameter added to both. Zero references to old table names.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p packages/mcp-server/tsconfig.json` — no type errors
2. `grep -rn "spx_daily\|spx_15min\|vix_intraday" packages/mcp-server/src/tools/market-data.ts` — zero matches (excluding intentional comments about old schema)
3. `grep -n "checkDataAvailability" packages/mcp-server/src/tools/market-data.ts` — appears in all three tool handlers
4. `grep -n "BB_Width\|Realized_Vol\|Prior_Range_vs_ATR" packages/mcp-server/src/tools/market-data.ts` — new filter candidates present
5. `grep -n "composite" packages/mcp-server/src/tools/market-data.ts` — composite filter suggestion logic present
6. `grep -n "Prior_Range_vs_ATR" packages/mcp-server/src/utils/market-enricher.ts` — computation present, schema gap comment removed
</verification>

<success_criteria>
- market-enricher.ts computes Prior_Range_vs_ATR and writes it to market.daily
- enrich_trades returns enriched trades with fields from both market.daily and market.context, including Prior_Range_vs_ATR as open-known
- analyze_regime_performance segments by regime data now sourced from market.context via JOIN
- suggest_filters includes BB_Width, Realized_Vol_5D/20D, BB_Position, Prior_Range_vs_ATR standalone filter candidates
- suggest_filters generates composite filter suggestions from top-performing standalone pairs
- All three tools have optional ticker parameter defaulting to SPX
- All three tools integrate checkDataAvailability with warnings in response
- Zero references to old table names in tool SQL strings
</success_criteria>

<output>
After completion, create `.planning/phases/63-tool-migration/63-02-SUMMARY.md`
</output>
