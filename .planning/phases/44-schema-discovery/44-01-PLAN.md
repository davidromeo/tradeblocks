---
phase: 44-schema-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mcp-server/src/utils/schema-metadata.ts
  - packages/mcp-server/src/tools/schema.ts
  - packages/mcp-server/src/index.ts
  - packages/mcp-server/src/cli-handler.ts
autonomous: true

must_haves:
  truths:
    - "Claude can list all available tables and their descriptions"
    - "Claude can get column names and types for any table"
    - "Example queries are available for common hypothesis patterns"
    - "Row counts and block breakdowns are included for trades.trade_data"
  artifacts:
    - path: "packages/mcp-server/src/utils/schema-metadata.ts"
      provides: "Hardcoded table/column descriptions and example queries"
      exports: ["SCHEMA_DESCRIPTIONS", "EXAMPLE_QUERIES"]
    - path: "packages/mcp-server/src/tools/schema.ts"
      provides: "describe_database MCP tool implementation"
      exports: ["registerSchemaTools"]
  key_links:
    - from: "packages/mcp-server/src/tools/schema.ts"
      to: "packages/mcp-server/src/utils/schema-metadata.ts"
      via: "import SCHEMA_DESCRIPTIONS, EXAMPLE_QUERIES"
      pattern: "import.*SCHEMA_DESCRIPTIONS.*from.*schema-metadata"
    - from: "packages/mcp-server/src/tools/schema.ts"
      to: "packages/mcp-server/src/db/connection.ts"
      via: "getConnection for DuckDB introspection"
      pattern: "getConnection"
    - from: "packages/mcp-server/src/tools/schema.ts"
      to: "packages/mcp-server/src/tools/middleware/sync-middleware.ts"
      via: "withFullSync for sync before introspection"
      pattern: "withFullSync"
    - from: "packages/mcp-server/src/index.ts"
      to: "packages/mcp-server/src/tools/schema.ts"
      via: "registerSchemaTools call in createServer"
      pattern: "registerSchemaTools\\(server"
---

<objective>
Implement describe_database MCP tool for Claude to discover the DuckDB schema structure before writing SQL queries.

Purpose: Claude needs to understand what tables and columns exist, their types and meanings, and see example queries before using run_sql. This tool provides complete schema context in a single call.

Output:
- Schema metadata file with hardcoded descriptions for all tables/columns
- describe_database tool that returns tables, columns, row counts, block breakdowns, and example queries
- Tool wired into MCP server and CLI handler
</objective>

<execution_context>
@/Users/davidromeo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidromeo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/44-schema-discovery/44-CONTEXT.md
@.planning/phases/44-schema-discovery/44-RESEARCH.md

# Reference for existing patterns
@packages/mcp-server/src/tools/sql.ts
@packages/mcp-server/src/tools/middleware/sync-middleware.ts
@packages/mcp-server/src/db/schemas.ts
@packages/mcp-server/src/utils/output-formatter.ts
@packages/mcp-server/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create schema metadata file</name>
  <files>packages/mcp-server/src/utils/schema-metadata.ts</files>
  <action>
Create a new TypeScript file with hardcoded schema metadata and example queries.

**SCHEMA_DESCRIPTIONS structure:**
- Organize by schema namespace (trades, market)
- Each schema has: description, tables object
- Each table has: description, keyColumns array, columns object
- Each column has: description (string), hypothesis (boolean flag for key analytical columns)

**Tables to document (from packages/mcp-server/src/db/schemas.ts):**
1. trades.trade_data - Individual trade records (14 columns)
2. market.spx_daily - Daily SPX data with 35 columns (indicators, VIX, regime)
3. market.spx_15min - 15-minute intraday checkpoints (38 columns)
4. market.spx_highlow - High/low timing data (17 columns)
5. market.vix_intraday - VIX intraday data (29 columns)

**Column descriptions guidance:**
- Focus on what each column means for trading analysis
- Mark hypothesis-relevant columns (block_id, date_opened, strategy, pl, VIX levels, regime, etc.)
- Keep descriptions to one line each

**EXAMPLE_QUERIES structure:**
Three categories (per CONTEXT.md):
1. basic: 3-4 queries (count by strategy, daily P&L, recent market)
2. joins: 3-4 queries (trades + market context, trades + intraday data)
3. hypothesis: 3-4 queries (win rate by regime, P&L by day of week, trending vs range)

Use examples from RESEARCH.md as starting point. Format as array of {description, sql} objects.

**Important:** Export TypeScript types for the metadata structure for IDE support.
  </action>
  <verify>
`npm run typecheck` in packages/mcp-server passes (no type errors in new file)
  </verify>
  <done>
schema-metadata.ts exports SCHEMA_DESCRIPTIONS and EXAMPLE_QUERIES with descriptions for all 5 tables and ~10 example queries across 3 categories
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement describe_database tool</name>
  <files>packages/mcp-server/src/tools/schema.ts</files>
  <action>
Create the describe_database MCP tool that returns comprehensive schema information.

**Tool registration pattern:**
- Follow pattern from sql.ts (import zod, McpServer, connection, middleware, output-formatter)
- Use withFullSync middleware (ensures tables exist before introspection)
- No input parameters needed (returns full database info)
- Export registerSchemaTools function

**Implementation steps inside handler:**

1. **Get tables from DuckDB introspection:**
```typescript
const tablesResult = await conn.runAndReadAll(`
  SELECT schema_name, table_name, column_count
  FROM duckdb_tables()
  WHERE internal = false
    AND schema_name IN ('trades', 'market')
    AND table_name NOT LIKE '%_sync_metadata'
  ORDER BY schema_name, table_name
`);
```

2. **For each table, get columns:**
```typescript
const columnsResult = await conn.runAndReadAll(`
  SELECT column_name, data_type, is_nullable
  FROM duckdb_columns()
  WHERE schema_name = '${schemaName}' AND table_name = '${tableName}'
  ORDER BY column_index
`);
```

3. **Get exact row counts:**
```typescript
const countResult = await conn.runAndReadAll(
  `SELECT COUNT(*) FROM ${schemaName}.${tableName}`
);
const rowCount = Number(countResult.getRows()[0][0]);
```

4. **For trades.trade_data only, get block breakdown:**
```typescript
const blockResult = await conn.runAndReadAll(`
  SELECT block_id, COUNT(*) as row_count
  FROM trades.trade_data
  GROUP BY block_id
  ORDER BY block_id
`);
```

5. **Merge introspection results with SCHEMA_DESCRIPTIONS:**
- For each table, combine DuckDB column types with hardcoded descriptions
- If column exists in SCHEMA_DESCRIPTIONS, include the description
- If not (shouldn't happen for stable schema), just include type

6. **Build output structure:**
```typescript
{
  schemas: {
    trades: {
      description: "...",
      tables: {
        trade_data: {
          description: "...",
          rowCount: 1234,
          blockBreakdown: [{blockId: "block-1", rowCount: 500}, ...],
          columns: [{name: "...", type: "...", description: "...", nullable: true, hypothesis: false}, ...]
        }
      }
    },
    market: { ... }
  },
  examples: EXAMPLE_QUERIES,
  syncInfo: {
    blocksProcessed: blockSyncResult.blocksProcessed,
    marketFilesSynced: marketSyncResult.filesSynced
  }
}
```

7. **Use createToolOutput:**
```typescript
const summary = `Database schema: ${tableCount} tables across 2 schemas (trades, market). ${totalRows} total rows.`;
return createToolOutput(summary, result);
```

**Tool description:**
```
"Get complete database schema: all tables, columns, types, row counts, and example queries. " +
"Call this BEFORE using run_sql to understand available data and query patterns. " +
"Returns schema organized by namespace (trades.*, market.*), with descriptions, " +
"row counts, block breakdowns for trades, and example SQL queries."
```
  </action>
  <verify>
`npm run typecheck` in packages/mcp-server passes
  </verify>
  <done>
schema.ts exports registerSchemaTools with describe_database tool that uses DuckDB introspection, merges with hardcoded descriptions, and returns structured output
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire tool and verify with CLI</name>
  <files>
packages/mcp-server/src/index.ts
packages/mcp-server/src/cli-handler.ts
  </files>
  <action>
1. **Update index.ts:**
- Add import: `import { registerSchemaTools } from "./tools/schema.js";`
- Call `registerSchemaTools(server, resolvedDir);` in createServer() function, after registerSQLTools

2. **Update cli-handler.ts:**
- Add import: `import { registerSchemaTools } from "./tools/schema.js";`
- Add `registerSchemaTools(server, baseDir);` in createServer function (for CLI test mode)

3. **Rebuild and verify with CLI:**
```bash
cd packages/mcp-server && npm run build
```

4. **Test the tool with real data:**
```bash
TRADEBLOCKS_DATA_DIR=~/backtests tradeblocks-mcp --call describe_database '{}'
```

Verify output contains:
- schemas.trades.tables.trade_data with rowCount and columns
- schemas.market.tables.spx_daily with columns
- blockBreakdown array for trades table (if data exists)
- examples.basic, examples.joins, examples.hypothesis arrays
- syncInfo with processing counts
  </action>
  <verify>
1. `npm run build` in packages/mcp-server succeeds (no compile errors)
2. CLI call returns structured JSON with schemas, examples, and syncInfo
3. `npm run typecheck` from repo root passes (no new type errors)
  </verify>
  <done>
describe_database tool is registered and callable via MCP and CLI, returns complete schema info with tables, columns, row counts, block breakdowns, and example queries
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Tool registration:**
   - describe_database appears in MCP tool list
   - CLI --call mode works with the tool

2. **Schema accuracy:**
   - All 5 tables are listed (trade_data, spx_daily, spx_15min, spx_highlow, vix_intraday)
   - Column types match actual DuckDB schema
   - Row counts are exact (not estimates)
   - Block breakdown shows per-block row counts for trades table

3. **Descriptions present:**
   - Every table has a description
   - Key columns have descriptions
   - Hypothesis-relevant columns are flagged

4. **Examples useful:**
   - 3-4 basic SQL examples
   - 3-4 JOIN examples between trades and market data
   - 3-4 hypothesis testing patterns (win rate by regime, P&L by day, etc.)

5. **Integration with run_sql workflow:**
   - Claude can call describe_database to learn schema
   - Claude can then write run_sql queries informed by the schema
</verification>

<success_criteria>
- describe_database tool returns all tables with accurate column info
- Row counts and block breakdowns included for data volume awareness
- Example queries cover basic, join, and hypothesis patterns
- Tool uses withFullSync (data is fresh before introspection)
- TypeScript compiles without errors
- CLI verification passes with real data
</success_criteria>

<output>
After completion, create `.planning/phases/44-schema-discovery/44-01-SUMMARY.md`
</output>
