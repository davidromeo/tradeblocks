---
phase: 42-sync-layer
plan: 04
type: execute
wave: 3
depends_on: ["42-02", "42-03"]
files_modified:
  - packages/mcp-server/src/tools/blocks.ts
autonomous: true

must_haves:
  truths:
    - "list_blocks triggers sync for ALL blocks before returning results"
    - "Per-block tools sync just their block on demand"
    - "Sync errors are included in tool response (syncErrors array)"
    - "Users experience fresh data without manual intervention"
  artifacts:
    - path: "packages/mcp-server/src/tools/blocks.ts"
      provides: "Sync-integrated MCP tools"
      contains: "syncAllBlocks"
  key_links:
    - from: "packages/mcp-server/src/tools/blocks.ts"
      to: "packages/mcp-server/src/sync/index.ts"
      via: "syncAllBlocks and syncBlock calls"
      pattern: "syncAllBlocks|syncBlock"
    - from: "list_blocks tool response"
      to: "syncResult.errors"
      via: "syncErrors array in output"
      pattern: "syncErrors"
---

<objective>
Wire sync layer into existing MCP tools so users experience automatic data freshness.

Purpose: Complete the sync layer by integrating it into the tool layer. Per CONTEXT.md: `list_blocks` syncs ALL blocks; per-block tools sync just their block.
Output: MCP tools automatically sync DuckDB before returning data, with errors reported in responses.
</objective>

<execution_context>
@/Users/davidromeo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidromeo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-sync-layer/42-CONTEXT.md
@.planning/phases/42-sync-layer/42-02-SUMMARY.md
@.planning/phases/42-sync-layer/42-03-SUMMARY.md

# Existing code to reference
@packages/mcp-server/src/tools/blocks.ts
@packages/mcp-server/src/sync/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate syncAllBlocks into list_blocks tool</name>
  <files>
    packages/mcp-server/src/tools/blocks.ts
  </files>
  <action>
Modify `packages/mcp-server/src/tools/blocks.ts`:

1. **Add import at top:**
   ```typescript
   import { syncAllBlocks, syncMarketData } from "../sync/index.js";
   ```

2. **Modify `list_blocks` tool handler** (around line 150):
   At the START of the handler, before any block listing logic:
   ```typescript
   // Sync all blocks before listing - ensures DuckDB is fresh
   const syncResult = await syncAllBlocks(baseDir);

   // Also sync market data (if _marketdata folder exists)
   const marketSyncResult = await syncMarketData(baseDir);
   ```

3. **Add syncErrors to response:**
   At the end of the tool output, add a syncErrors section if there were any:
   ```typescript
   // Build output
   const output = {
     // ... existing fields ...
     blocks: formattedBlocks,
     // Add sync info
     ...(syncResult.errors.length > 0 || marketSyncResult.errors.length > 0 ? {
       syncErrors: [...syncResult.errors, ...marketSyncResult.errors]
     } : {})
   };
   ```

4. **Optional: Add sync stats to response** (informational):
   ```typescript
   syncInfo: {
     blocksProcessed: syncResult.blocksProcessed,
     blocksSynced: syncResult.synced,
     blocksUnchanged: syncResult.unchanged,
     blocksDeleted: syncResult.deleted,
     marketFilesSynced: marketSyncResult.synced
   }
   ```
   This helps Claude understand if sync happened and what changed.

**Key behavior per CONTEXT.md:**
- Sync blocks the query until complete (always accurate results)
- First query pays sync cost, subsequent queries are fast DB reads
- Sync errors are reported but don't block the response
  </action>
  <verify>
- `npm run build` succeeds
- `list_blocks` imports and calls `syncAllBlocks` and `syncMarketData`
- Response includes syncErrors array when errors occur
  </verify>
  <done>list_blocks syncs ALL blocks and market data before returning results.</done>
</task>

<task type="auto">
  <name>Task 2: Add per-block sync to get_statistics tool</name>
  <files>
    packages/mcp-server/src/tools/blocks.ts
  </files>
  <action>
Modify the `get_statistics` tool in `blocks.ts`:

1. **Add import if not already present:**
   ```typescript
   import { syncBlock } from "../sync/index.js";
   ```

2. **At the start of get_statistics handler**, add single-block sync:
   ```typescript
   // Sync this block before querying - ensures fresh data
   const syncResult = await syncBlock(blockId, baseDir);

   // If block was deleted or errored, handle appropriately
   if (syncResult.status === 'deleted') {
     return createToolOutput({
       error: `Block '${blockId}' no longer exists (folder was deleted)`
     });
   }
   if (syncResult.status === 'error') {
     // Continue with potentially stale data but warn
     // (per CONTEXT.md: skip failed blocks, continue others)
   }
   ```

3. **Add syncInfo to response if sync occurred:**
   ```typescript
   const response = {
     // ... existing stats fields ...
     ...(syncResult.status === 'synced' ? {
       syncInfo: { status: 'synced', tradeCount: syncResult.tradeCount }
     } : {}),
     ...(syncResult.status === 'error' ? {
       syncWarning: syncResult.error
     } : {})
   };
   ```

**Note:** This adds per-block lazy sync. If a user calls `get_statistics` directly without `list_blocks` first, the single block is synced on demand.
  </action>
  <verify>
- `npm run build` succeeds
- `get_statistics` calls `syncBlock` at start of handler
- Deleted blocks return appropriate error
  </verify>
  <done>get_statistics syncs its block before returning data.</done>
</task>

<task type="auto">
  <name>Task 3: Add per-block sync to other block-dependent tools</name>
  <files>
    packages/mcp-server/src/tools/blocks.ts
  </files>
  <action>
Add the same per-block sync pattern to these tools in `blocks.ts`:

1. **`get_trades`** - Add at start of handler:
   ```typescript
   const syncResult = await syncBlock(blockId, baseDir);
   if (syncResult.status === 'deleted') {
     return createToolOutput({
       error: `Block '${blockId}' no longer exists`
     });
   }
   ```

2. **`compare_portfolios`** - Sync each blockId before comparison:
   ```typescript
   for (const blockId of blockIds) {
     await syncBlock(blockId, baseDir);
   }
   ```

3. **`calculate_correlation_matrix`** - Same pattern, sync each block

4. **`analyze_tail_risk`** - Sync blockId before analysis

5. **`run_monte_carlo`** - Sync blockId before simulation

6. **`run_walk_forward`** - Sync blockId before analysis

**Pattern for all:**
- Call `syncBlock(blockId, baseDir)` at start of handler
- For deleted blocks, return error early
- For sync errors, continue with warning (data may be stale but tool still works)

**Why this matters:**
- Users may call these tools directly without `list_blocks` first
- Each tool pays sync cost only for its required block(s)
- Subsequent calls to same block are instant (hash unchanged)
  </action>
  <verify>
- `npm run build` succeeds
- All block-dependent tools have syncBlock call at handler start
- Tools handle deleted blocks gracefully
  </verify>
  <done>All block-dependent tools sync their blocks on demand.</done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds in packages/mcp-server
2. `list_blocks` calls syncAllBlocks() and syncMarketData() before listing
3. Per-block tools (get_statistics, get_trades, etc.) call syncBlock()
4. Sync errors are reported in tool responses (syncErrors or syncWarning)
5. Deleted blocks return appropriate error messages
</verification>

<success_criteria>
- Users experience automatic data freshness (no manual sync needed)
- list_blocks syncs ALL blocks before returning
- Per-block tools sync just their block on demand
- Sync errors are visible in tool responses for Claude to surface
- First query pays sync cost, subsequent queries are instant (hash unchanged)
</success_criteria>

<output>
After completion, create `.planning/phases/42-sync-layer/42-04-SUMMARY.md`
</output>
